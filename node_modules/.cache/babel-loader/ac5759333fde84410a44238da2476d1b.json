{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar reactLayoutEffect = require('react-layout-effect');\n\nvar shared = require('@react-spring/shared');\n\nvar _extends = _interopDefault(require('@babel/runtime/helpers/extends'));\n\nvar React = require('react');\n\nvar _regeneratorRuntime = _interopDefault(require('@babel/runtime/regenerator'));\n\nvar _asyncToGenerator = _interopDefault(require('@babel/runtime/helpers/asyncToGenerator'));\n\nvar _createClass = _interopDefault(require('@babel/runtime/helpers/createClass'));\n\nvar _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));\n\nvar animated = require('@react-spring/animated/index.cjs.js');\n\nvar G = require('@react-spring/shared/globals');\n\nvar useMemoOne = require('use-memo-one');\n\nvar _wrapNativeSuper = _interopDefault(require('@babel/runtime/helpers/wrapNativeSuper'));\n\nvar deprecations = require('@react-spring/shared/deprecations');\n\nvar _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));\n\nvar _assertThisInitialized = _interopDefault(require('@babel/runtime/helpers/assertThisInitialized'));\n\nvar stringInterpolation = require('@react-spring/shared/stringInterpolation');\n\nvar types = require('@react-spring/shared/types');\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\n\nfunction useChain(refs, timeSteps, timeFrame) {\n  if (timeFrame === void 0) {\n    timeFrame = 1000;\n  }\n\n  reactLayoutEffect.useLayoutEffect(function () {\n    if (timeSteps) {\n      var prevDelay = 0;\n      shared.each(refs, function (ref, i) {\n        if (!ref.current) return;\n        var controllers = ref.current.controllers;\n\n        if (controllers.length) {\n          var delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          shared.each(controllers, function (ctrl) {\n            shared.each(ctrl.queue, function (props) {\n              props.delay = delay + (props.delay || 0);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      var p = Promise.resolve();\n      shared.each(refs, function (ref) {\n        var _ref = ref.current || {},\n            controllers = _ref.controllers,\n            start = _ref.start;\n\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          var updates = controllers.map(function (ctrl) {\n            var q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(function () {\n            shared.each(controllers, function (ctrl, i) {\n              var _ctrl$queue;\n\n              return (_ctrl$queue = ctrl.queue).push.apply(_ctrl$queue, updates[i]);\n            });\n            return start();\n          });\n        }\n      });\n    }\n  });\n} // The `mass` prop defaults to 1\n\n\nvar config = {\n  \"default\": {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nvar linear = function linear(t) {\n  return t;\n};\n\nvar defaults = _extends(_extends({}, config[\"default\"]), {}, {\n  mass: 1,\n  damping: 1,\n  easing: linear,\n  clamp: false\n});\n\nvar AnimationConfig =\n/**\n * With higher tension, the spring will resist bouncing and try harder to stop at its end value.\n *\n * When tension is zero, no animation occurs.\n */\n\n/**\n * The damping ratio coefficient, or just the damping ratio when `speed` is defined.\n *\n * When `speed` is defined, this value should be between 0 and 1.\n *\n * Higher friction means the spring will slow down faster.\n */\n\n/**\n * The natural frequency (in seconds), which dictates the number of bounces\n * per second when no damping exists.\n *\n * When defined, `tension` is derived from this, and `friction` is derived\n * from `tension` and `damping`.\n */\n\n/**\n * The damping ratio, which dictates how the spring slows down.\n *\n * Set to `0` to never slow down. Set to `1` to slow down without bouncing.\n * Between `0` and `1` is for you to explore.\n *\n * Only works when `frequency` is defined.\n *\n * Defaults to 1\n */\n\n/**\n * Higher mass means more friction is required to slow down.\n *\n * Defaults to 1, which works fine most of the time.\n */\n\n/**\n * The initial velocity of one or more values.\n */\n\n/**\n * The smallest velocity before the animation is considered \"not moving\".\n *\n * When undefined, `precision` is used instead.\n */\n\n/**\n * The smallest distance from a value before that distance is essentially zero.\n *\n * This helps in deciding when a spring is \"at rest\". The spring must be within\n * this distance from its final value, and its velocity must be lower than this\n * value too (unless `restVelocity` is defined).\n */\n\n/**\n * For `duration` animations only. Note: The `duration` is not affected\n * by this property.\n *\n * Defaults to `0`, which means \"start from the beginning\".\n *\n * Setting to `1+` makes an immediate animation.\n *\n * Setting to `0.5` means \"start from the middle of the easing function\".\n *\n * Any number `>= 0` and `<= 1` makes sense here.\n */\n\n/**\n * Animation length in number of milliseconds.\n */\n\n/**\n * The animation curve. Only used when `duration` is defined.\n *\n * Defaults to quadratic ease-in-out.\n */\n\n/**\n * Avoid overshooting by ending abruptly at the goal value.\n */\n\n/**\n * When above zero, the spring will bounce instead of overshooting when\n * exceeding its goal value. Its velocity is multiplied by `-1 + bounce`\n * whenever its current value equals or exceeds its goal. For example,\n * setting `bounce` to `0.5` chops the velocity in half on each bounce,\n * in addition to any friction.\n */\n\n/**\n * \"Decay animations\" decelerate without an explicit goal value.\n * Useful for scrolling animations.\n *\n * Use `true` for the default exponential decay factor (`0.998`).\n *\n * When a `number` between `0` and `1` is given, a lower number makes the\n * animation slow down faster. And setting to `1` would make an unending\n * animation.\n */\n\n/**\n * While animating, round to the nearest multiple of this number.\n * The `from` and `to` values are never rounded, as well as any value\n * passed to the `set` method of an animated value.\n */\nfunction AnimationConfig() {\n  this.tension = void 0;\n  this.friction = void 0;\n  this.frequency = void 0;\n  this.damping = void 0;\n  this.mass = void 0;\n  this.velocity = 0;\n  this.restVelocity = void 0;\n  this.precision = void 0;\n  this.progress = void 0;\n  this.duration = void 0;\n  this.easing = void 0;\n  this.clamp = void 0;\n  this.bounce = void 0;\n  this.decay = void 0;\n  this.round = void 0;\n  Object.assign(this, defaults);\n};\n\nfunction mergeConfig(config, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = _extends({}, defaultConfig);\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = _extends(_extends({}, defaultConfig), newConfig);\n  }\n\n  sanitizeConfig(config, newConfig);\n  Object.assign(config, newConfig);\n\n  for (var key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key];\n    }\n  }\n\n  var mass = config.mass,\n      frequency = config.frequency,\n      damping = config.damping;\n\n  if (!shared.is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01;\n    if (damping < 0) damping = 0;\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n\n  return config;\n} // Prevent a config from accidentally overriding new props.\n// This depends on which \"config\" props take precedence when defined.\n\n\nfunction sanitizeConfig(config, props) {\n  if (!shared.is.und(props.decay)) {\n    config.duration = undefined;\n  } else {\n    var isTensionConfig = !shared.is.und(props.tension) || !shared.is.und(props.friction);\n\n    if (isTensionConfig || !shared.is.und(props.frequency) || !shared.is.und(props.damping) || !shared.is.und(props.mass)) {\n      config.duration = undefined;\n      config.decay = undefined;\n    }\n\n    if (isTensionConfig) {\n      config.frequency = undefined;\n    }\n  }\n}\n\nvar emptyArray = [];\n/** @internal */\n\n/** An animation being executed by the frameloop */\n\nvar Animation = function Animation() {\n  this.changed = false;\n  this.values = emptyArray;\n  this.toValues = null;\n  this.fromValues = emptyArray;\n  this.to = void 0;\n  this.from = void 0;\n  this.config = new AnimationConfig();\n  this.immediate = false;\n  this.onStart = void 0;\n  this.onChange = void 0;\n  this.onRest = [];\n};\n\nfunction _createForOfIteratorHelperLoose(o) {\n  var i = 0;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  i = o[Symbol.iterator]();\n  return i.next.bind(i);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n} // @see https://github.com/alexreardon/use-memo-one/pull/10\n\n\nvar useMemo = function useMemo(create, deps) {\n  return useMemoOne.useMemoOne(create, deps || [{}]);\n};\n\nfunction callProp(value) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return shared.is.fun(value) ? value.apply(void 0, args) : value;\n}\n/** Try to coerce the given value into a boolean using the given key */\n\n\nvar matchProp = function matchProp(value, key) {\n  return value === true || !!(key && value && (shared.is.fun(value) ? value(key) : shared.toArray(value).includes(key)));\n};\n\nvar getProps = function getProps(props, i, arg) {\n  return props && (shared.is.fun(props) ? props(i, arg) : shared.is.arr(props) ? props[i] : _extends({}, props));\n};\n/** Returns `true` if the given prop is having its default value set. */\n\n\nvar hasDefaultProp = function hasDefaultProp(props, key) {\n  return !shared.is.und(getDefaultProp(props, key));\n};\n/** Get the default value being set for the given `key` */\n\n\nvar getDefaultProp = function getDefaultProp(props, key) {\n  return props[\"default\"] === true ? props[key] : props[\"default\"] ? props[\"default\"][key] : undefined;\n};\n/**\n * Extract the default props from an update.\n *\n * When the `default` prop is falsy, this function still behaves as if\n * `default: true` was used. The `default` prop is always respected when\n * truthy.\n */\n\n\nvar getDefaultProps = function getDefaultProps(props, omitKeys, defaults) {\n  if (omitKeys === void 0) {\n    omitKeys = [];\n  }\n\n  if (defaults === void 0) {\n    defaults = {};\n  }\n\n  var keys = DEFAULT_PROPS;\n\n  if (props[\"default\"] && props[\"default\"] !== true) {\n    props = props[\"default\"];\n    keys = Object.keys(props);\n  }\n\n  for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {\n    var key = _step.value;\n    var value = props[key];\n\n    if (!shared.is.und(value) && !omitKeys.includes(key)) {\n      defaults[key] = value;\n    }\n  }\n\n  return defaults;\n};\n/** Merge the default props of an update into a props cache. */\n\n\nvar mergeDefaultProps = function mergeDefaultProps(defaults, props, omitKeys) {\n  return getDefaultProps(props, omitKeys, defaults);\n};\n/** These props can have default values */\n\n\nvar DEFAULT_PROPS = ['pause', 'cancel', 'config', 'immediate', 'onDelayEnd', 'onProps', 'onStart', 'onChange', 'onRest'];\nvar RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  \"default\": 1,\n  delay: 1,\n  onDelayEnd: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onRest: 1,\n  // Transition props\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  // Internal props\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\n/**\n * Extract any properties whose keys are *not* reserved for customizing your\n * animations. All hooks use this function, which means `useTransition` props\n * are reserved for `useSpring` calls, etc.\n */\n\nfunction getForwardProps(props) {\n  var forward = {};\n  var count = 0;\n  shared.each(props, function (value, prop) {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n\n  if (count) {\n    return forward;\n  }\n}\n/**\n * Clone the given `props` and move all non-reserved props\n * into the `to` prop.\n */\n\n\nfunction inferTo(props) {\n  var to = getForwardProps(props);\n\n  if (to) {\n    var out = {\n      to: to\n    };\n    shared.each(props, function (val, key) {\n      return key in to || (out[key] = val);\n    });\n    return out;\n  }\n\n  return _extends({}, props);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\n\nfunction computeGoal(value) {\n  var config = shared.getFluidConfig(value);\n  return config ? computeGoal(config.get()) : shared.is.arr(value) ? value.map(computeGoal) : shared.isAnimatedString(value) ? G.createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n/**\n * This function sets a timeout if both the `delay` prop exists and\n * the `cancel` prop is not `true`.\n *\n * The `actions.start` function must handle the `cancel` prop itself,\n * but the `pause` prop is taken care of.\n */\n\n\nfunction scheduleProps(callId, _ref) {\n  var key = _ref.key,\n      props = _ref.props,\n      state = _ref.state,\n      actions = _ref.actions;\n  return new Promise(function (resolve, reject) {\n    var delay;\n    var timeout;\n    var pause = false;\n    var cancel = matchProp(props.cancel, key);\n\n    if (cancel) {\n      onStart();\n    } else {\n      delay = callProp(props.delay || 0, key);\n      pause = matchProp(props.pause, key);\n\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      timeout.cancel(); // Cache the remaining delay.\n\n      delay = timeout.time - shared.Globals.now();\n    }\n\n    function onResume() {\n      if (delay > 0) {\n        state.pauseQueue.add(onPause);\n        timeout = shared.Globals.frameLoop.setTimeout(onStart, delay);\n      } else {\n        onStart();\n      }\n    }\n\n    function onStart() {\n      state.pauseQueue[\"delete\"](onPause); // Maybe cancelled during its delay.\n\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n\n      try {\n        actions.start(_extends(_extends({}, props), {}, {\n          callId: callId,\n          delay: delay,\n          cancel: cancel,\n          pause: pause\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n/** @internal */\n\n/** The object given to the `onRest` prop and `start` promise. */\n\n/** The promised result of an animation. */\n\n/** @internal */\n\n\nvar getCombinedResult = function getCombinedResult(target, results) {\n  return results.length == 1 ? results[0] : results.some(function (result) {\n    return result.cancelled;\n  }) ? getCancelledResult(target) : results.every(function (result) {\n    return result.noop;\n  }) ? getNoopResult(target) : getFinishedResult(target, results.every(function (result) {\n    return result.finished;\n  }));\n};\n/** No-op results are for updates that never start an animation. */\n\n\nvar getNoopResult = function getNoopResult(target, value) {\n  if (value === void 0) {\n    value = target.get();\n  }\n\n  return {\n    value: value,\n    noop: true,\n    finished: true,\n    target: target\n  };\n};\n\nvar getFinishedResult = function getFinishedResult(target, finished, value) {\n  if (value === void 0) {\n    value = target.get();\n  }\n\n  return {\n    value: value,\n    finished: finished,\n    target: target\n  };\n};\n\nvar getCancelledResult = function getCancelledResult(target, value) {\n  if (value === void 0) {\n    value = target.get();\n  }\n\n  return {\n    value: value,\n    cancelled: true,\n    target: target\n  };\n};\n\nfunction _createForOfIteratorHelperLoose$1(o) {\n  var i = 0;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray$1(o))) return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  i = o[Symbol.iterator]();\n  return i.next.bind(i);\n}\n\nfunction _unsupportedIterableToArray$1(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);\n}\n\nfunction _arrayLikeToArray$1(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\n * Start an async chain or an async script.\n *\n * Always call `runAsync` in the action callback of a `scheduleProps` call.\n *\n * The `T` parameter can be a set of animated values (as an object type)\n * or a primitive type for a single animated value.\n */\n\n\nfunction runAsync(_x, _x2, _x3, _x4) {\n  return _runAsync.apply(this, arguments);\n}\n\nfunction _runAsync() {\n  _runAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(to, props, state, target) {\n    var callId, parentId, onRest, prevTo, prevPromise;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!props.pause) {\n              _context4.next = 3;\n              break;\n            }\n\n            _context4.next = 3;\n            return new Promise(function (resume) {\n              state.resumeQueue.add(resume);\n            });\n\n          case 3:\n            callId = props.callId, parentId = props.parentId, onRest = props.onRest;\n            prevTo = state.asyncTo, prevPromise = state.promise;\n\n            if (!(!parentId && to === prevTo && !props.reset)) {\n              _context4.next = 7;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", prevPromise);\n\n          case 7:\n            return _context4.abrupt(\"return\", state.promise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n              var defaultProps, preventBail, bail, bailPromise, withBailHandler, bailIfEnded, animate, result, animating;\n              return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      state.asyncId = callId;\n                      state.asyncTo = to; // The default props of any `animate` calls.\n\n                      defaultProps = getDefaultProps(props, [// The `onRest` prop is only called when the `runAsync` promise is resolved.\n                      'onRest']); // This promise is rejected when the animation is interrupted.\n\n                      bailPromise = new Promise(function (resolve, reject) {\n                        return preventBail = resolve, bail = reject;\n                      }); // Stop animating when an error is caught.\n\n                      withBailHandler = function withBailHandler(fn) {\n                        return function () {\n                          var onError = function onError(err) {\n                            if (err instanceof BailSignal) {\n                              bail(err); // Stop animating.\n                            }\n\n                            throw err;\n                          };\n\n                          try {\n                            return fn.apply(void 0, arguments)[\"catch\"](onError);\n                          } catch (err) {\n                            onError(err);\n                          }\n                        };\n                      };\n\n                      bailIfEnded = function bailIfEnded(bailSignal) {\n                        var bailResult = // The `cancel` prop or `stop` method was used.\n                        callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.\n                        callId !== state.asyncId && getFinishedResult(target, false);\n\n                        if (bailResult) {\n                          bailSignal.result = bailResult;\n                          throw bailSignal;\n                        }\n                      }; // Note: This function cannot use the `async` keyword, because we want the\n                      // `throw` statements to interrupt the caller.\n\n\n                      animate = withBailHandler(function (arg1, arg2) {\n                        var bailSignal = new BailSignal();\n                        bailIfEnded(bailSignal);\n                        var props = shared.is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n                          to: arg1\n                        });\n                        props.parentId = callId;\n                        shared.each(defaultProps, function (value, key) {\n                          if (shared.is.und(props[key])) {\n                            props[key] = value;\n                          }\n                        });\n                        return target.start(props).then( /*#__PURE__*/function () {\n                          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(result) {\n                            return _regeneratorRuntime.wrap(function _callee$(_context) {\n                              while (1) {\n                                switch (_context.prev = _context.next) {\n                                  case 0:\n                                    bailIfEnded(bailSignal);\n\n                                    if (!target.is('PAUSED')) {\n                                      _context.next = 4;\n                                      break;\n                                    }\n\n                                    _context.next = 4;\n                                    return new Promise(function (resume) {\n                                      state.resumeQueue.add(resume);\n                                    });\n\n                                  case 4:\n                                    return _context.abrupt(\"return\", result);\n\n                                  case 5:\n                                  case \"end\":\n                                    return _context.stop();\n                                }\n                              }\n                            }, _callee);\n                          }));\n\n                          return function (_x5) {\n                            return _ref2.apply(this, arguments);\n                          };\n                        }());\n                      });\n                      _context3.prev = 7; // Async sequence\n\n                      if (shared.is.arr(to)) {\n                        animating = function () {\n                          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(queue) {\n                            var _iterator, _step, _props;\n\n                            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                              while (1) {\n                                switch (_context2.prev = _context2.next) {\n                                  case 0:\n                                    _iterator = _createForOfIteratorHelperLoose$1(queue);\n\n                                  case 1:\n                                    if ((_step = _iterator()).done) {\n                                      _context2.next = 7;\n                                      break;\n                                    }\n\n                                    _props = _step.value;\n                                    _context2.next = 5;\n                                    return animate(_props);\n\n                                  case 5:\n                                    _context2.next = 1;\n                                    break;\n\n                                  case 7:\n                                  case \"end\":\n                                    return _context2.stop();\n                                }\n                              }\n                            }, _callee2);\n                          }));\n\n                          return function (_x6) {\n                            return _ref3.apply(this, arguments);\n                          };\n                        }()(to);\n                      } // Async script\n                      else if (shared.is.fun(to)) {\n                          animating = Promise.resolve(to(animate, target.stop.bind(target)));\n                        }\n\n                      _context3.next = 11;\n                      return Promise.all([animating.then(preventBail), bailPromise]);\n\n                    case 11:\n                      result = getFinishedResult(target, true); // Bail handling\n\n                      _context3.next = 21;\n                      break;\n\n                    case 14:\n                      _context3.prev = 14;\n                      _context3.t0 = _context3[\"catch\"](7);\n\n                      if (!(_context3.t0 instanceof BailSignal)) {\n                        _context3.next = 20;\n                        break;\n                      }\n\n                      result = _context3.t0.result;\n                      _context3.next = 21;\n                      break;\n\n                    case 20:\n                      throw _context3.t0;\n\n                    case 21:\n                      _context3.prev = 21;\n\n                      if (callId == state.asyncId) {\n                        state.asyncId = parentId;\n                        state.asyncTo = parentId ? prevTo : undefined;\n                        state.promise = parentId ? prevPromise : undefined;\n                      }\n\n                      return _context3.finish(21);\n\n                    case 24:\n                      if (shared.is.fun(onRest)) {\n                        G.batchedUpdates(function () {\n                          onRest(result);\n                        });\n                      }\n\n                      return _context3.abrupt(\"return\", result);\n\n                    case 26:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3, null, [[7, 14, 21, 24]]);\n            }))());\n\n          case 8:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _runAsync.apply(this, arguments);\n}\n\nfunction cancelAsync(state, callId) {\n  state.cancelId = callId;\n  state.asyncId = state.asyncTo = state.promise = undefined;\n}\n/** This error is thrown to signal an interrupted async animation. */\n\n\nvar BailSignal = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(BailSignal, _Error);\n\n  function BailSignal() {\n    var _this;\n\n    _this = _Error.call(this, 'An async animation has been interrupted. You see this error because you ' + 'forgot to use `await` or `.catch(...)` on its returned promise.') || this;\n    _this.result = void 0;\n    return _this;\n  }\n\n  return BailSignal;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar isFrameValue = function isFrameValue(value) {\n  return value instanceof FrameValue;\n};\n\nvar nextId = 1;\n/**\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\n *\n * Its underlying value can be accessed and even observed.\n */\n\nvar FrameValue = /*#__PURE__*/function (_FluidValue) {\n  _inheritsLoose(FrameValue, _FluidValue);\n\n  function FrameValue() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _FluidValue.call.apply(_FluidValue, [this].concat(args)) || this;\n    _this.id = nextId++;\n    _this.key = void 0;\n    _this._priority = 0;\n    _this._children = new Set();\n    return _this;\n  }\n\n  var _proto = FrameValue.prototype;\n  /** Get the current value */\n\n  _proto.get = function get() {\n    var node = animated.getAnimated(this);\n    return node && node.getValue();\n  }\n  /** Create a spring that maps our value to another value */\n  ;\n\n  _proto.to = function to() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return G.to(this, args);\n  }\n  /** @deprecated Use the `to` method instead. */\n  ;\n\n  _proto.interpolate = function interpolate() {\n    deprecations.deprecateInterpolate();\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return G.to(this, args);\n  }\n  /** @internal */\n  ;\n  /** @internal */\n\n\n  _proto.addChild = function addChild(child) {\n    if (!this._children.size) this._attach();\n\n    this._children.add(child);\n  }\n  /** @internal */\n  ;\n\n  _proto.removeChild = function removeChild(child) {\n    this._children[\"delete\"](child);\n\n    if (!this._children.size) this._detach();\n  }\n  /** @internal */\n  ;\n\n  _proto.onParentChange = function onParentChange(_ref) {\n    var type = _ref.type;\n\n    if (this.idle) {\n      // Start animating when a parent does.\n      if (type == 'start') {\n        this._reset();\n\n        this._start();\n      }\n    } // Reset our animation state when a parent does, but only when\n    // our animation is active.\n    else if (type == 'reset') {\n        this._reset();\n      }\n  }\n  /** Called when the first child is added. */\n  ;\n\n  _proto._attach = function _attach() {}\n  /** Called when the last child is removed. */\n  ;\n\n  _proto._detach = function _detach() {}\n  /**\n   * Reset our animation state (eg: start values, velocity, etc)\n   * and tell our children to do the same.\n   *\n   * This is called when our goal value is changed during (or before)\n   * an animation.\n   */\n  ;\n\n  _proto._reset = function _reset() {\n    this._emit({\n      type: 'reset',\n      parent: this\n    });\n  }\n  /**\n   * Start animating if possible.\n   *\n   * Note: Be sure to call `_reset` first, or the animation will break.\n   * This method would like to call `_reset` for you, but that would\n   * interfere with paused animations.\n   */\n  ;\n\n  _proto._start = function _start() {\n    this._emit({\n      type: 'start',\n      parent: this\n    });\n  }\n  /** Tell our children about our new value */\n  ;\n\n  _proto._onChange = function _onChange(value, idle) {\n    if (idle === void 0) {\n      idle = false;\n    }\n\n    this._emit({\n      type: 'change',\n      parent: this,\n      value: value,\n      idle: idle\n    });\n  }\n  /** Tell our children about our new priority */\n  ;\n\n  _proto._onPriorityChange = function _onPriorityChange(priority) {\n    if (!this.idle) {\n      // Make the frameloop aware of our new priority.\n      G.frameLoop.start(this);\n    }\n\n    this._emit({\n      type: 'priority',\n      parent: this,\n      priority: priority\n    });\n  };\n\n  _proto._emit = function _emit(event) {\n    // Clone \"_children\" so it can be safely mutated inside the loop.\n    shared.each(Array.from(this._children), function (child) {\n      child.onParentChange(event);\n    });\n  };\n\n  _createClass(FrameValue, [{\n    key: \"priority\",\n    get: function get() {\n      return this._priority;\n    },\n    set: function set(priority) {\n      if (this._priority != priority) {\n        this._priority = priority;\n\n        this._onPriorityChange(priority);\n      }\n    }\n  }]);\n\n  return FrameValue;\n}(shared.FluidValue); // TODO: use \"const enum\" when Babel supports it\n\n/** The spring has not animated yet */\n\n\nvar CREATED = 'CREATED';\n/** The spring has animated before */\n\nvar IDLE = 'IDLE';\n/** The spring is animating */\n\nvar ACTIVE = 'ACTIVE';\n/** The spring is frozen in time */\n\nvar PAUSED = 'PAUSED';\n/** The spring cannot be animated */\n\nvar DISPOSED = 'DISPOSED';\n/**\n * Only numbers, strings, and arrays of numbers/strings are supported.\n * Non-animatable strings are also supported.\n */\n\nvar SpringValue = /*#__PURE__*/function (_FrameValue) {\n  _inheritsLoose(SpringValue, _FrameValue);\n\n  function SpringValue(arg1, arg2) {\n    var _this;\n\n    _this = _FrameValue.call(this) || this;\n    _this.key = void 0;\n    _this.animation = new Animation();\n    _this.queue = void 0;\n    _this._phase = CREATED;\n    _this._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    _this._defaultProps = {};\n    _this._lastCallId = 0;\n    _this._lastToId = 0;\n\n    if (!shared.is.und(arg1) || !shared.is.und(arg2)) {\n      var _props = shared.is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n        from: arg1\n      });\n\n      _props[\"default\"] = true;\n\n      _this.start(_props);\n    }\n\n    return _this;\n  }\n\n  var _proto = SpringValue.prototype;\n  /** Advance the current animation by a number of milliseconds */\n\n  _proto.advance = function advance(dt) {\n    var _this2 = this;\n\n    var idle = true;\n    var changed = false;\n    var anim = this.animation;\n    var config = anim.config,\n        toValues = anim.toValues;\n    var payload = animated.getPayload(anim.to);\n\n    if (!payload) {\n      var toConfig = shared.getFluidConfig(anim.to);\n\n      if (toConfig) {\n        toValues = shared.toArray(toConfig.get());\n      }\n    }\n\n    anim.values.forEach(function (node, i) {\n      if (node.done) return; // The \"anim.toValues\" array must exist when no parent exists.\n\n      var to = payload ? payload[i].lastPosition : toValues[i];\n      var finished = anim.immediate;\n      var position = to;\n\n      if (!finished) {\n        position = node.lastPosition; // Loose springs never move.\n\n        if (config.tension <= 0) {\n          node.done = true;\n          return;\n        }\n\n        var elapsed = node.elapsedTime += dt;\n        var _from = anim.fromValues[i];\n        var v0 = node.v0 != null ? node.v0 : node.v0 = shared.is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n        var velocity; // Duration easing\n\n        if (!shared.is.und(config.duration)) {\n          var p = config.progress || 0;\n          if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);\n          position = _from + config.easing(p) * (to - _from);\n          velocity = (position - node.lastPosition) / dt;\n          finished = p == 1;\n        } // Decay easing\n        else if (config.decay) {\n            var decay = config.decay === true ? 0.998 : config.decay;\n            var e = Math.exp(-(1 - decay) * elapsed);\n            position = _from + v0 / (1 - decay) * (1 - e);\n            finished = Math.abs(node.lastPosition - position) < 0.1; // derivative of position\n\n            velocity = v0 * e;\n          } // Spring easing\n          else {\n              velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n              /** The smallest distance from a value before being treated like said value. */\n\n              var precision = config.precision || (_from == to ? 0.005 : Math.min(1, Math.abs(to - _from) * 0.001));\n              /** The velocity at which movement is essentially none */\n\n              var restVelocity = config.restVelocity || precision / 10; // Bouncing is opt-in (not to be confused with overshooting)\n\n              var bounceFactor = config.clamp ? 0 : config.bounce;\n              var canBounce = !shared.is.und(bounceFactor);\n              /** When `true`, the value is increasing over time */\n\n              var isGrowing = _from == to ? node.v0 > 0 : _from < to;\n              /** When `true`, the velocity is considered moving */\n\n              var isMoving;\n              /** When `true`, the velocity is being deflected or clamped */\n\n              var isBouncing = false;\n              var step = 1; // 1ms\n\n              var numSteps = Math.ceil(dt / step);\n\n              for (var n = 0; n < numSteps; ++n) {\n                isMoving = Math.abs(velocity) > restVelocity;\n\n                if (!isMoving) {\n                  finished = Math.abs(to - position) <= precision;\n\n                  if (finished) {\n                    break;\n                  }\n                }\n\n                if (canBounce) {\n                  isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.\n\n                  if (isBouncing) {\n                    velocity = -velocity * bounceFactor;\n                    position = to;\n                  }\n                }\n\n                var springForce = -config.tension * 0.000001 * (position - to);\n                var dampingForce = -config.friction * 0.001 * velocity;\n                var acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2\n\n                velocity = velocity + acceleration * step; // pt/ms\n\n                position = position + velocity * step;\n              }\n            }\n\n        node.lastVelocity = velocity;\n\n        if (Number.isNaN(position)) {\n          console.warn(\"Got NaN while animating:\", _this2);\n          finished = true;\n        }\n      } // Parent springs must finish before their children can.\n\n\n      if (payload && !payload[i].done) {\n        finished = false;\n      }\n\n      if (finished) {\n        node.done = true;\n      } else {\n        idle = false;\n      }\n\n      if (node.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n\n    if (idle) {\n      this.finish();\n    } else if (changed) {\n      this._onChange(this.get());\n    }\n\n    return idle;\n  }\n  /** Check the current phase */\n  ;\n\n  _proto.is = function is(phase) {\n    return this._phase == phase;\n  }\n  /** Set the current value, while stopping the current animation */\n  ;\n\n  _proto.set = function set(value) {\n    var _this3 = this;\n\n    G.batchedUpdates(function () {\n      _this3._focus(value);\n\n      if (_this3._set(value)) {\n        // Ensure change observers are notified. When active,\n        // the \"_stop\" method handles this.\n        if (!_this3.is(ACTIVE)) {\n          return _this3._onChange(_this3.get(), true);\n        }\n      }\n\n      _this3._stop();\n    });\n    return this;\n  }\n  /**\n   * Freeze the active animation in time.\n   * This does nothing when not animating.\n   */\n  ;\n\n  _proto.pause = function pause() {\n    checkDisposed(this, 'pause');\n\n    if (!this.is(PAUSED)) {\n      this._phase = PAUSED;\n      shared.flush(this._state.pauseQueue, function (onPause) {\n        return onPause();\n      });\n    }\n  }\n  /** Resume the animation if paused. */\n  ;\n\n  _proto.resume = function resume() {\n    checkDisposed(this, 'resume');\n\n    if (this.is(PAUSED)) {\n      this._start();\n\n      shared.flush(this._state.resumeQueue, function (onResume) {\n        return onResume();\n      });\n    }\n  }\n  /**\n   * Skip to the end of the current animation.\n   *\n   * All `onRest` callbacks are passed `{finished: true}`\n   */\n  ;\n\n  _proto.finish = function finish(to) {\n    var _this4 = this;\n\n    this.resume();\n\n    if (this.is(ACTIVE)) {\n      var anim = this.animation; // Decay animations have an implicit goal.\n\n      if (!anim.config.decay && shared.is.und(to)) {\n        to = anim.to;\n      } // Set the value if we can.\n\n\n      if (!shared.is.und(to)) {\n        this._set(to);\n      }\n\n      G.batchedUpdates(function () {\n        // Ensure the \"onStart\" and \"onRest\" props are called.\n        if (!anim.changed) {\n          anim.changed = true;\n\n          if (anim.onStart) {\n            anim.onStart(_this4);\n          }\n        } // Exit the frameloop.\n\n\n        _this4._stop();\n      });\n    }\n\n    return this;\n  }\n  /** Push props into the pending queue. */\n  ;\n\n  _proto.update = function update(props) {\n    checkDisposed(this, 'update');\n    var queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n  /**\n   * Update this value's animation using the queue of pending props,\n   * and unpause the current animation (if one is frozen).\n   *\n   * When arguments are passed, a new animation is created, and the\n   * queued animations are left alone.\n   */\n  ;\n\n  _proto.start = /*#__PURE__*/function () {\n    var _start2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(to, arg2) {\n      var _this5 = this;\n\n      var queue, results;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              checkDisposed(this, 'start');\n\n              if (!shared.is.und(to)) {\n                queue = [shared.is.obj(to) ? to : _extends(_extends({}, arg2), {}, {\n                  to: to\n                })];\n              } else {\n                queue = this.queue || [];\n                this.queue = [];\n              }\n\n              _context.next = 4;\n              return Promise.all(queue.map(function (props) {\n                return _this5._update(props);\n              }));\n\n            case 4:\n              results = _context.sent;\n              return _context.abrupt(\"return\", getCombinedResult(this, results));\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function start(_x, _x2) {\n      return _start2.apply(this, arguments);\n    }\n\n    return start;\n  }()\n  /**\n   * Stop the current animation, and cancel any delayed updates.\n   *\n   * Pass `true` to call `onRest` with `cancelled: true`.\n   */\n  ;\n\n  _proto.stop = function stop(cancel) {\n    var _this6 = this;\n\n    if (!this.is(DISPOSED)) {\n      cancelAsync(this._state, this._lastCallId); // Ensure the `to` value equals the current value.\n\n      this._focus(this.get()); // Exit the frameloop and notify `onRest` listeners.\n\n\n      G.batchedUpdates(function () {\n        return _this6._stop(cancel);\n      });\n    }\n\n    return this;\n  }\n  /** Restart the animation. */\n  ;\n\n  _proto.reset = function reset() {\n    this._update({\n      reset: true\n    });\n  }\n  /** Prevent future animations, and stop the current animation */\n  ;\n\n  _proto.dispose = function dispose() {\n    if (!this.is(DISPOSED)) {\n      if (this.animation) {\n        // Prevent \"onRest\" calls when disposed.\n        this.animation.onRest = [];\n      }\n\n      this.stop();\n      this._phase = DISPOSED;\n    }\n  }\n  /** @internal */\n  ;\n\n  _proto.onParentChange = function onParentChange(event) {\n    _FrameValue.prototype.onParentChange.call(this, event);\n\n    if (event.type == 'change') {\n      if (!this.is(ACTIVE)) {\n        this._reset();\n\n        if (!this.is(PAUSED)) {\n          this._start();\n        }\n      }\n    } else if (event.type == 'priority') {\n      this.priority = event.priority + 1;\n    }\n  }\n  /**\n   * Parse the `to` and `from` range from the given `props` object.\n   *\n   * This also ensures the initial value is available to animated components\n   * during the render phase.\n   */\n  ;\n\n  _proto._prepareNode = function _prepareNode(_ref) {\n    var to = _ref.to,\n        from = _ref.from,\n        reverse = _ref.reverse;\n    var key = this.key || '';\n    to = !shared.is.obj(to) || shared.getFluidConfig(to) ? to : to[key];\n    from = !shared.is.obj(from) || shared.getFluidConfig(from) ? from : from[key]; // Create the range now to avoid \"reverse\" logic.\n\n    var range = {\n      to: to,\n      from: from\n    }; // Before ever animating, this method ensures an `Animated` node\n    // exists and keeps its value in sync with the \"from\" prop.\n\n    if (this.is(CREATED)) {\n      if (reverse) {\n        var _ref2 = [from, to];\n        to = _ref2[0];\n        from = _ref2[1];\n      }\n\n      from = shared.getFluidValue(from);\n\n      var node = this._updateNode(shared.is.und(from) ? shared.getFluidValue(to) : from);\n\n      if (node && !shared.is.und(from)) {\n        node.setValue(from);\n      }\n    }\n\n    return range;\n  }\n  /**\n   * Create an `Animated` node if none exists or the given value has an\n   * incompatible type. Do nothing if `value` is undefined.\n   *\n   * The newest `Animated` node is returned.\n   */\n  ;\n\n  _proto._updateNode = function _updateNode(value) {\n    var node = animated.getAnimated(this);\n\n    if (!shared.is.und(value)) {\n      var nodeType = this._getNodeType(value);\n\n      if (!node || node.constructor !== nodeType) {\n        animated.setAnimated(this, node = nodeType.create(value));\n      }\n    }\n\n    return node;\n  }\n  /** Return the `Animated` node constructor for a given value */\n  ;\n\n  _proto._getNodeType = function _getNodeType(value) {\n    var parentNode = animated.getAnimated(value);\n    return parentNode ? parentNode.constructor : shared.is.arr(value) ? animated.AnimatedArray : shared.isAnimatedString(value) ? animated.AnimatedString : animated.AnimatedValue;\n  }\n  /** Schedule an animation to run after an optional delay */\n  ;\n\n  _proto._update = function _update(props, isLoop) {\n    var _this7 = this;\n\n    var defaultProps = this._defaultProps;\n\n    var mergeDefaultProp = function mergeDefaultProp(key) {\n      var value = getDefaultProp(props, key);\n\n      if (!shared.is.und(value)) {\n        defaultProps[key] = value;\n      } // For `cancel` and `pause`, a truthy default always wins.\n\n\n      if (defaultProps[key]) {\n        props[key] = defaultProps[key];\n      }\n    }; // These props are coerced into booleans by the `scheduleProps` function,\n    // so they need their default values processed before then.\n\n\n    mergeDefaultProp('cancel');\n    mergeDefaultProp('pause'); // Ensure the initial value can be accessed by animated components.\n\n    var range = this._prepareNode(props);\n\n    return scheduleProps(++this._lastCallId, {\n      key: this.key,\n      props: props,\n      state: this._state,\n      actions: {\n        pause: this.pause.bind(this),\n        resume: this.resume.bind(this),\n        start: this._merge.bind(this, range)\n      }\n    }).then(function (result) {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        var nextProps = createLoopUpdate(props);\n\n        if (nextProps) {\n          return _this7._update(nextProps, true);\n        }\n      }\n\n      return result;\n    });\n  }\n  /** Merge props into the current animation */\n  ;\n\n  _proto._merge = function _merge(range, props, resolve) {\n    // The \"cancel\" prop cancels all pending delays and it forces the\n    // active animation to stop where it is.\n    if (props.cancel) {\n      this.stop(true);\n      return resolve(getCancelledResult(this));\n    }\n\n    var key = this.key,\n        anim = this.animation;\n    var defaultProps = this._defaultProps;\n    /** The \"to\" prop is defined. */\n\n    var hasToProp = !shared.is.und(range.to);\n    /** The \"from\" prop is defined. */\n\n    var hasFromProp = !shared.is.und(range.from); // Avoid merging other props if implicitly prevented, except\n    // when both the \"to\" and \"from\" props are undefined.\n\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId;\n      } else {\n        return resolve(getCancelledResult(this));\n      }\n    }\n    /** Get the value of a prop, or its default value */\n\n\n    var get = function get(prop) {\n      return !shared.is.und(props[prop]) ? props[prop] : defaultProps[prop];\n    }; // Call \"onDelayEnd\" before merging props, but after cancellation checks.\n\n\n    var onDelayEnd = coerceEventProp(get('onDelayEnd'), key);\n\n    if (onDelayEnd) {\n      onDelayEnd(props, this);\n    }\n\n    if (props[\"default\"]) {\n      mergeDefaultProps(defaultProps, props, ['pause', 'cancel']);\n    }\n\n    var prevTo = anim.to,\n        prevFrom = anim.from;\n    var _range$to = range.to,\n        to = _range$to === void 0 ? prevTo : _range$to,\n        _range$from = range.from,\n        from = _range$from === void 0 ? prevFrom : _range$from; // Focus the \"from\" value if changing without a \"to\" value.\n\n    if (hasFromProp && !hasToProp) {\n      to = from;\n    } // Flip the current range if \"reverse\" is true.\n\n\n    if (props.reverse) {\n      var _ref3 = [from, to];\n      to = _ref3[0];\n      from = _ref3[1];\n    }\n    /** The \"from\" value is changing. */\n\n\n    var hasFromChanged = !shared.isEqual(from, prevFrom);\n\n    if (hasFromChanged) {\n      anim.from = from;\n    }\n    /** The \"to\" value is changing. */\n\n\n    var hasToChanged = !shared.isEqual(to, prevTo);\n\n    if (hasToChanged) {\n      this._focus(to);\n    } // Both \"from\" and \"to\" can use a fluid config (thanks to http://npmjs.org/fluids).\n\n\n    var toConfig = shared.getFluidConfig(to);\n    var fromConfig = shared.getFluidConfig(from);\n\n    if (fromConfig) {\n      from = fromConfig.get();\n    }\n    /** The \"to\" prop is async. */\n\n\n    var hasAsyncTo = shared.is.arr(props.to) || shared.is.fun(props.to);\n    var config = anim.config;\n    var decay = config.decay,\n        velocity = config.velocity; // The \"runAsync\" function treats the \"config\" prop as a default,\n    // so we must avoid merging it when the \"to\" prop is async.\n\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(config, callProp(props.config, key), // Avoid calling the same \"config\" prop twice.\n      props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\n    } // This instance might not have its Animated node yet. For example,\n    // the constructor can be given props without a \"to\" or \"from\" value.\n\n\n    var node = animated.getAnimated(this);\n\n    if (!node || shared.is.und(to)) {\n      return resolve(getFinishedResult(this, true));\n    }\n    /** When true, start at the \"from\" value. */\n\n\n    var reset = // When `reset` is undefined, the `from` prop implies `reset: true`,\n    // except for declarative updates. When `reset` is defined, there\n    // must exist a value to animate from.\n    shared.is.und(props.reset) ? hasFromProp && !props[\"default\"] : !shared.is.und(from) && matchProp(props.reset, key); // The current value, where the animation starts from.\n\n    var value = reset ? from : this.get(); // The animation ends at this value, unless \"to\" is fluid.\n\n    var goal = computeGoal(to); // Only specific types can be animated to/from.\n\n    var isAnimatable = shared.is.num(goal) || shared.is.arr(goal) || shared.isAnimatedString(goal); // When true, the value changes instantly on the next frame.\n\n    var immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n\n    if (hasToChanged) {\n      if (immediate) {\n        node = this._updateNode(goal);\n      } else {\n        var nodeType = this._getNodeType(to);\n\n        if (nodeType !== node.constructor) {\n          throw Error(\"Cannot animate between \" + node.constructor.name + \" and \" + nodeType.name + \", as the \\\"to\\\" prop suggests\");\n        }\n      }\n    } // The type of Animated node for the goal value.\n\n\n    var goalType = node.constructor; // When the goal value is fluid, we don't know if its value\n    // will change before the next animation frame, so it always\n    // starts the animation to be safe.\n\n    var started = !!toConfig;\n    var finished = false;\n\n    if (!started) {\n      // When true, the current value has probably changed.\n      var hasValueChanged = reset || this.is(CREATED) && hasFromChanged; // When the \"to\" value or current value are changed,\n      // start animating if not already finished.\n\n      if (hasToChanged || hasValueChanged) {\n        finished = shared.isEqual(computeGoal(value), goal);\n        started = !finished;\n      } // Changing \"decay\" or \"velocity\" starts the animation.\n\n\n      if (!shared.isEqual(config.decay, decay) || !shared.isEqual(config.velocity, velocity)) {\n        started = true;\n      }\n    } // When an active animation changes its goal to its current value:\n\n\n    if (finished && this.is(ACTIVE)) {\n      // Avoid an abrupt stop unless the animation is being reset.\n      if (anim.changed && !reset) {\n        started = true;\n      } // Stop the animation before its first frame.\n      else if (!started) {\n          this._stop();\n        }\n    }\n\n    if (!hasAsyncTo) {\n      // Make sure our \"toValues\" are updated even if our previous\n      // \"to\" prop is a fluid value whose current value is also ours.\n      if (started || shared.getFluidConfig(prevTo)) {\n        anim.values = node.getPayload();\n        anim.toValues = toConfig ? null : goalType == animated.AnimatedString ? [1] : shared.toArray(goal);\n      }\n\n      anim.immediate = immediate;\n      anim.onStart = coerceEventProp(get('onStart'), key);\n      anim.onChange = coerceEventProp(get('onChange'), key); // The \"reset\" prop tries to reuse the old \"onRest\" prop,\n      // unless you defined a new \"onRest\" prop.\n\n      var onRestQueue = anim.onRest;\n      var onRest = reset && !props.onRest ? onRestQueue[0] || shared.noop : checkFinishedOnRest(coerceEventProp(get('onRest'), key), this); // In most cases, the animation after this one won't reuse our\n      // \"onRest\" prop. Instead, the _default_ \"onRest\" prop is used\n      // when the next animation has an undefined \"onRest\" prop.\n\n      if (started) {\n        anim.onRest = [onRest, checkFinishedOnRest(resolve, this)]; // Flush the \"onRest\" queue for the previous animation.\n\n        var onRestIndex = reset ? 0 : 1;\n\n        if (onRestIndex < onRestQueue.length) {\n          G.batchedUpdates(function () {\n            for (; onRestIndex < onRestQueue.length; onRestIndex++) {\n              onRestQueue[onRestIndex]();\n            }\n          });\n        }\n      } // The \"onRest\" prop is always first, and it can be updated even\n      // if a new animation is not started by this update.\n      else if (reset || props.onRest) {\n          anim.onRest[0] = onRest;\n        }\n    } // By this point, every prop has been merged.\n\n\n    var onProps = coerceEventProp(get('onProps'), key);\n\n    if (onProps) {\n      onProps(props, this);\n    } // Update our node even if the animation is idle.\n\n\n    if (reset) {\n      node.setValue(value);\n    }\n\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this));\n    } // Start an animation\n    else if (started) {\n        // Must be idle for \"onStart\" to be called again.\n        if (reset) this._phase = IDLE;\n\n        this._reset();\n\n        this._start();\n      } // Postpone promise resolution until the animation is finished,\n      // so that no-op updates still resolve at the expected time.\n      else if (this.is(ACTIVE) && !hasToChanged) {\n          anim.onRest.push(checkFinishedOnRest(resolve, this));\n        } // Resolve our promise immediately.\n        else {\n            resolve(getNoopResult(this, value));\n          }\n  }\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n  ;\n\n  _proto._focus = function _focus(value) {\n    var anim = this.animation;\n\n    if (value !== anim.to) {\n      var config = shared.getFluidConfig(anim.to);\n\n      if (config) {\n        config.removeChild(this);\n      }\n\n      anim.to = value;\n      var priority = 0;\n\n      if (config = shared.getFluidConfig(value)) {\n        config.addChild(this);\n\n        if (isFrameValue(value)) {\n          priority = (value.priority || 0) + 1;\n        }\n      }\n\n      this.priority = priority;\n    }\n  }\n  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */\n  ;\n\n  _proto._set = function _set(value) {\n    var config = shared.getFluidConfig(value);\n\n    if (config) {\n      value = config.get();\n    }\n\n    var node = animated.getAnimated(this);\n    var oldValue = node && node.getValue();\n\n    if (node) {\n      node.setValue(value);\n    } else {\n      this._updateNode(value);\n    }\n\n    return !shared.isEqual(value, oldValue);\n  };\n\n  _proto._onChange = function _onChange(value, idle) {\n    if (idle === void 0) {\n      idle = false;\n    }\n\n    var anim = this.animation; // The \"onStart\" prop is called on the first change after entering the\n    // frameloop, but never for immediate animations.\n\n    if (!anim.changed && !idle) {\n      anim.changed = true;\n\n      if (anim.onStart) {\n        anim.onStart(this);\n      }\n    }\n\n    if (anim.onChange) {\n      anim.onChange(value, this);\n    }\n\n    _FrameValue.prototype._onChange.call(this, value, idle);\n  };\n\n  _proto._reset = function _reset() {\n    var anim = this.animation; // Reset the state of each Animated node.\n\n    animated.getAnimated(this).reset(anim.to); // Ensure the `onStart` prop will be called.\n\n    if (!this.is(ACTIVE)) {\n      anim.changed = false;\n    } // Use the current values as the from values.\n\n\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(function (node) {\n        return node.lastPosition;\n      });\n    }\n\n    _FrameValue.prototype._reset.call(this);\n  };\n\n  _proto._start = function _start() {\n    if (!this.is(ACTIVE)) {\n      this._phase = ACTIVE;\n\n      _FrameValue.prototype._start.call(this); // The \"skipAnimation\" global avoids the frameloop.\n\n\n      if (G.skipAnimation) {\n        this.finish();\n      } else {\n        G.frameLoop.start(this);\n      }\n    }\n  }\n  /**\n   * Exit the frameloop and notify `onRest` listeners.\n   *\n   * Always wrap `_stop` calls with `batchedUpdates`.\n   */\n  ;\n\n  _proto._stop = function _stop(cancel) {\n    this.resume();\n\n    if (this.is(ACTIVE)) {\n      this._phase = IDLE; // Always let change observers know when a spring becomes idle.\n\n      this._onChange(this.get(), true);\n\n      var anim = this.animation;\n      shared.each(anim.values, function (node) {\n        node.done = true;\n      });\n      var onRestQueue = anim.onRest;\n\n      if (onRestQueue.length) {\n        // Preserve the \"onRest\" prop when the goal is dynamic.\n        anim.onRest = [anim.toValues ? shared.noop : onRestQueue[0]]; // Never call the \"onRest\" prop for no-op animations.\n\n        if (!anim.changed) {\n          onRestQueue[0] = shared.noop;\n        }\n\n        shared.each(onRestQueue, function (onRest) {\n          return onRest(cancel);\n        });\n      }\n    }\n  };\n\n  _createClass(SpringValue, [{\n    key: \"idle\",\n    get: function get() {\n      return !this.is(ACTIVE) && !this._state.asyncTo;\n    }\n  }, {\n    key: \"goal\",\n    get: function get() {\n      return shared.getFluidValue(this.animation.to);\n    }\n  }, {\n    key: \"velocity\",\n    get: function get() {\n      var node = animated.getAnimated(this);\n      return node instanceof animated.AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(function (node) {\n        return node.lastVelocity || 0;\n      });\n    }\n  }]);\n\n  return SpringValue;\n}(FrameValue);\n\nfunction checkDisposed(spring, name) {\n  if (spring.is(DISPOSED)) {\n    throw Error(\"Cannot call \\\"\" + name + \"\\\" of disposed \\\"\" + spring.constructor.name + \"\\\" object\");\n  }\n}\n/** Coerce an event prop to an event handler */\n\n\nfunction coerceEventProp(prop, key) {\n  return shared.is.fun(prop) ? prop : key && prop ? prop[key] : undefined;\n}\n/**\n * The \"finished\" value is determined by each \"onRest\" handler,\n * based on whether the current value equals the goal value that\n * was calculated at the time the \"onRest\" handler was set.\n */\n\n\nvar checkFinishedOnRest = function checkFinishedOnRest(onRest, spring) {\n  var to = spring.animation.to;\n  return onRest ? function (cancel) {\n    if (cancel) {\n      onRest(getCancelledResult(spring));\n    } else {\n      var goal = computeGoal(to);\n      var value = computeGoal(spring.get());\n      var finished = shared.isEqual(value, goal);\n      onRest(getFinishedResult(spring, finished));\n    }\n  } : shared.noop;\n};\n\nfunction createLoopUpdate(props, loop, to) {\n  if (loop === void 0) {\n    loop = props.loop;\n  }\n\n  if (to === void 0) {\n    to = props.to;\n  }\n\n  var loopRet = callProp(loop);\n\n  if (loopRet) {\n    var overrides = loopRet !== true && inferTo(loopRet);\n    var reverse = (overrides || props).reverse;\n    var reset = !overrides || overrides.reset;\n    return createUpdate(_extends(_extends({}, props), {}, {\n      loop: loop,\n      // Avoid updating default props when looping.\n      \"default\": false,\n      // For the \"reverse\" prop to loop as expected, the \"to\" prop\n      // must be undefined. The \"reverse\" prop is ignored when the\n      // \"to\" prop is an array or function.\n      to: !reverse || shared.is.arr(to) || shared.is.fun(to) ? to : undefined,\n      // Avoid defining the \"from\" prop if a reset is unwanted.\n      from: reset ? props.from : undefined,\n      reset: reset\n    }, overrides));\n  }\n}\n/**\n * Return a new object based on the given `props`.\n *\n * - All unreserved props are moved into the `to` prop object.\n * - The `to` and `from` props are deleted when falsy.\n * - The `keys` prop is set to an array of affected keys,\n *   or `null` if all keys are affected.\n */\n\n\nfunction createUpdate(props) {\n  var _props2 = props = inferTo(props),\n      to = _props2.to,\n      from = _props2.from; // Collect the keys affected by this update.\n\n\n  var keys = new Set();\n\n  if (from) {\n    findDefined(from, keys);\n  } else {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.from;\n  }\n\n  if (shared.is.obj(to)) {\n    findDefined(to, keys);\n  } else if (!to) {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.to;\n  } // The \"keys\" prop helps in applying updates to affected keys only.\n\n\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\n/**\n * A modified version of `createUpdate` meant for declarative APIs.\n */\n\n\nfunction declareUpdate(props) {\n  var update = createUpdate(props);\n\n  if (shared.is.und(update[\"default\"])) {\n    update[\"default\"] = getDefaultProps(update, [// Avoid forcing `immediate: true` onto imperative updates.\n    update.immediate === true && 'immediate']);\n  }\n\n  return update;\n}\n/** Find keys with defined values */\n\n\nfunction findDefined(values, keys) {\n  shared.each(values, function (value, key) {\n    return value != null && keys.add(key);\n  });\n}\n/** Events batched by the `Controller` class */\n\n\nvar BATCHED_EVENTS = ['onStart', 'onChange', 'onRest'];\nvar nextId$1 = 1;\n/** Queue of pending updates for a `Controller` instance. */\n\nvar Controller = /*#__PURE__*/function () {\n  /** The animated values */\n\n  /** The queue of props passed to the `update` method. */\n\n  /** Custom handler for flushing update queues */\n\n  /** These props are used by all future spring values */\n\n  /** The combined phase of our spring values */\n\n  /** The counter for tracking `scheduleProps` calls */\n\n  /** The values currently being animated */\n\n  /** State used by the `runAsync` function */\n\n  /** The event queues that are flushed once per frame maximum */\n  function Controller(props, flush) {\n    this.id = nextId$1++;\n    this.springs = {};\n    this.queue = [];\n    this._flush = void 0;\n    this._initialProps = void 0;\n    this._phase = CREATED;\n    this._lastAsyncId = 0;\n    this._active = new Set();\n    this._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    this._events = {\n      onStart: new Set(),\n      onChange: new Set(),\n      onRest: new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n\n    if (flush) {\n      this._flush = flush;\n    }\n\n    if (props) {\n      this.start(props);\n    }\n  }\n  /**\n   * Equals `true` when no spring values are in the frameloop, and\n   * no async animation is currently active.\n   */\n\n\n  var _proto = Controller.prototype;\n  /** Check the current phase */\n\n  _proto.is = function is(phase) {\n    return this._phase == phase;\n  }\n  /** Get the current values of our springs */\n  ;\n\n  _proto.get = function get() {\n    var values = {};\n    this.each(function (spring, key) {\n      return values[key] = spring.get();\n    });\n    return values;\n  }\n  /** Push an update onto the queue of each value. */\n  ;\n\n  _proto.update = function update(props) {\n    if (props) this.queue.push(createUpdate(props));\n    return this;\n  }\n  /**\n   * Start the queued animations for every spring, and resolve the returned\n   * promise once all queued animations have finished or been cancelled.\n   *\n   * When you pass a queue (instead of nothing), that queue is used instead of\n   * the queued animations added with the `update` method, which are left alone.\n   */\n  ;\n\n  _proto.start = function start(props) {\n    var queue = props ? shared.toArray(props).map(createUpdate) : this.queue;\n\n    if (!props) {\n      this.queue = [];\n    }\n\n    if (this._flush) {\n      return this._flush(this, queue);\n    }\n\n    prepareKeys(this, queue);\n    return flushUpdateQueue(this, queue);\n  }\n  /** Stop one animation, some animations, or all animations */\n  ;\n\n  _proto.stop = function stop(keys) {\n    if (shared.is.und(keys)) {\n      this.each(function (spring) {\n        return spring.stop();\n      });\n      cancelAsync(this._state, this._lastAsyncId);\n    } else {\n      var springs = this.springs;\n      shared.each(shared.toArray(keys), function (key) {\n        return springs[key].stop();\n      });\n    }\n\n    return this;\n  }\n  /** Freeze the active animation in time */\n  ;\n\n  _proto.pause = function pause(keys) {\n    if (shared.is.und(keys)) {\n      this.each(function (spring) {\n        return spring.pause();\n      });\n    } else {\n      var springs = this.springs;\n      shared.each(shared.toArray(keys), function (key) {\n        return springs[key].pause();\n      });\n    }\n\n    return this;\n  }\n  /** Resume the animation if paused. */\n  ;\n\n  _proto.resume = function resume(keys) {\n    if (shared.is.und(keys)) {\n      this.each(function (spring) {\n        return spring.resume();\n      });\n    } else {\n      var springs = this.springs;\n      shared.each(shared.toArray(keys), function (key) {\n        return springs[key].resume();\n      });\n    }\n\n    return this;\n  }\n  /** Restart every animation. */\n  ;\n\n  _proto.reset = function reset() {\n    this.each(function (spring) {\n      return spring.reset();\n    }); // TODO: restart async \"to\" prop\n\n    return this;\n  }\n  /** Call a function once per spring value */\n  ;\n\n  _proto.each = function each(iterator) {\n    shared.each(this.springs, iterator);\n  }\n  /** Destroy every spring in this controller */\n  ;\n\n  _proto.dispose = function dispose() {\n    this._state.asyncTo = undefined;\n    this.each(function (spring) {\n      return spring.dispose();\n    });\n    this.springs = {};\n  }\n  /** @internal Called at the end of every animation frame */\n  ;\n\n  _proto._onFrame = function _onFrame() {\n    var _this = this;\n\n    var _this$_events = this._events,\n        onStart = _this$_events.onStart,\n        onChange = _this$_events.onChange,\n        onRest = _this$_events.onRest;\n    var isActive = this._active.size > 0;\n\n    if (isActive && this._phase != ACTIVE) {\n      this._phase = ACTIVE;\n      shared.flush(onStart, function (onStart) {\n        return onStart(_this);\n      });\n    }\n\n    var values = (onChange.size || !isActive && onRest.size) && this.get();\n    shared.flush(onChange, function (onChange) {\n      return onChange(values);\n    }); // The \"onRest\" queue is only flushed when all springs are idle.\n\n    if (!isActive) {\n      this._phase = IDLE;\n      shared.flush(onRest, function (_ref) {\n        var onRest = _ref[0],\n            result = _ref[1];\n        result.value = values;\n        onRest(result);\n      });\n    }\n  }\n  /** @internal */\n  ;\n\n  _proto.onParentChange = function onParentChange(event) {\n    if (event.type == 'change') {\n      this._active[event.idle ? 'delete' : 'add'](event.parent);\n\n      G.frameLoop.onFrame(this._onFrame);\n    }\n  };\n\n  _createClass(Controller, [{\n    key: \"idle\",\n    get: function get() {\n      return !this._state.asyncTo && Object.values(this.springs).every(function (spring) {\n        return spring.idle;\n      });\n    }\n  }]);\n\n  return Controller;\n}();\n/**\n * Warning: Props might be mutated.\n */\n\n\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map(function (props) {\n    return flushUpdate(ctrl, props);\n  })).then(function (results) {\n    return getCombinedResult(ctrl, results);\n  });\n}\n/**\n * Warning: Props might be mutated.\n *\n * Process a single set of props using the given controller.\n *\n * The returned promise resolves to `true` once the update is\n * applied and any animations it starts are finished without being\n * stopped or cancelled.\n */\n\n\nfunction flushUpdate(ctrl, props, isLoop) {\n  var to = props.to,\n      loop = props.loop,\n      onRest = props.onRest; // Looping must be handled in this function, or else the values\n  // would end up looping out-of-sync in many common cases.\n\n  if (loop) {\n    props.loop = false;\n  }\n\n  var asyncTo = shared.is.arr(to) || shared.is.fun(to) ? to : undefined;\n\n  if (asyncTo) {\n    props.to = undefined;\n    props.onRest = undefined;\n  } else {\n    // For certain events, use batching to prevent multiple calls per frame.\n    // However, batching is avoided when the `to` prop is async, because any\n    // event props are used as default props instead.\n    shared.each(BATCHED_EVENTS, function (key) {\n      var handler = props[key];\n\n      if (shared.is.fun(handler)) {\n        var queue = ctrl['_events'][key];\n\n        if (queue instanceof Set) {\n          props[key] = function () {\n            return queue.add(handler);\n          };\n        } else {\n          props[key] = function (_ref2) {\n            var finished = _ref2.finished,\n                cancelled = _ref2.cancelled;\n            var result = queue.get(handler);\n\n            if (result) {\n              if (!finished) result.finished = false;\n              if (cancelled) result.cancelled = true;\n            } else {\n              // The \"value\" is set before the \"handler\" is called.\n              queue.set(handler, {\n                value: null,\n                finished: finished,\n                cancelled: cancelled\n              });\n            }\n          };\n        }\n      }\n    });\n  }\n\n  var keys = props.keys || Object.keys(ctrl.springs);\n  var promises = keys.map(function (key) {\n    return ctrl.springs[key].start(props);\n  }); // Schedule the \"asyncTo\" if defined.\n\n  var state = ctrl['_state'];\n\n  if (asyncTo) {\n    promises.push(scheduleProps(++ctrl['_lastAsyncId'], {\n      props: props,\n      state: state,\n      actions: {\n        pause: shared.noop,\n        resume: shared.noop,\n        start: function start(props, resolve) {\n          props.onRest = onRest;\n\n          if (!props.cancel) {\n            resolve(runAsync(asyncTo, props, state, ctrl));\n          } // Prevent `cancel: true` from ending the current `runAsync` call,\n          // except when the default `cancel` prop is being set.\n          else if (hasDefaultProp(props, 'cancel')) {\n              cancelAsync(state, props.callId);\n            }\n        }\n      }\n    }));\n  } // Respect the `cancel` prop when no keys are affected.\n  else if (!props.keys && props.cancel === true) {\n      cancelAsync(state, ctrl['_lastAsyncId']);\n    }\n\n  return Promise.all(promises).then(function (results) {\n    var result = getCombinedResult(ctrl, results);\n\n    if (loop && result.finished && !(isLoop && result.noop)) {\n      var nextProps = createLoopUpdate(props, loop, to);\n\n      if (nextProps) {\n        prepareKeys(ctrl, [nextProps]);\n        return flushUpdate(ctrl, nextProps, true);\n      }\n    }\n\n    return result;\n  });\n}\n/**\n * From an array of updates, get the map of `SpringValue` objects\n * by their keys. Springs are created when any update wants to\n * animate a new key.\n *\n * Springs created by `getSprings` are neither cached nor observed\n * until they're given to `setSprings`.\n */\n\n\nfunction getSprings(ctrl, props) {\n  var springs = _extends({}, ctrl.springs);\n\n  if (props) {\n    shared.each(shared.toArray(props), function (props) {\n      if (shared.is.und(props.keys)) {\n        props = createUpdate(props);\n      }\n\n      if (!shared.is.obj(props.to)) {\n        // Avoid passing array/function to each spring.\n        props = _extends(_extends({}, props), {}, {\n          to: undefined\n        });\n      }\n\n      prepareSprings(springs, props, function (key) {\n        return createSpring(key);\n      });\n    });\n  }\n\n  return springs;\n}\n/**\n * Tell a controller to manage the given `SpringValue` objects\n * whose key is not already in use.\n */\n\n\nfunction setSprings(ctrl, springs) {\n  shared.each(springs, function (spring, key) {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      spring.addChild(ctrl);\n    }\n  });\n}\n\nfunction createSpring(key, observer) {\n  var spring = new SpringValue();\n  spring.key = key;\n\n  if (observer) {\n    spring.addChild(observer);\n  }\n\n  return spring;\n}\n/**\n * Ensure spring objects exist for each defined key.\n *\n * Using the `props`, the `Animated` node of each `SpringValue` may\n * be created or updated.\n */\n\n\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    shared.each(props.keys, function (key) {\n      var spring = springs[key] || (springs[key] = create(key));\n      spring['_prepareNode'](props);\n    });\n  }\n}\n/**\n * Ensure spring objects exist for each defined key, and attach the\n * `ctrl` to them for observation.\n *\n * The queue is expected to contain `createUpdate` results.\n */\n\n\nfunction prepareKeys(ctrl, queue) {\n  shared.each(queue, function (props) {\n    prepareSprings(ctrl.springs, props, function (key) {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n/**\n * This context affects all new and existing `SpringValue` objects\n * created with the hook API or the renderprops API.\n */\n\n\nvar ctx = React.createContext({});\n\nvar SpringContext = function SpringContext(_ref) {\n  var children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  var inherited = React.useContext(ctx); // Memoize the context to avoid unwanted renders.\n\n  props = useMemo(function () {\n    return _extends(_extends({}, inherited), props);\n  }, [inherited, props.pause, props.cancel, props.immediate, props.config]);\n  var Provider = ctx.Provider;\n  return /*#__PURE__*/React.createElement(Provider, {\n    value: props\n  }, children);\n};\n\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\n/** Get the current values of nearest `SpringContext` component. */\n\nvar useSpringContext = function useSpringContext() {\n  return React.useContext(ctx);\n};\n/** Create an imperative API for manipulating an array of `Controller` objects. */\n\n\nvar SpringHandle = {\n  create: function create(getControllers) {\n    return {\n      get controllers() {\n        return getControllers();\n      },\n\n      update: function update(props) {\n        shared.each(getControllers(), function (ctrl, i) {\n          ctrl.update(getProps(props, i, ctrl));\n        });\n        return this;\n      },\n      start: function start(props) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var results;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return Promise.all(getControllers().map(function (ctrl, i) {\n                    var update = getProps(props, i, ctrl);\n                    return ctrl.start(update);\n                  }));\n\n                case 2:\n                  results = _context.sent;\n                  return _context.abrupt(\"return\", {\n                    value: results.map(function (result) {\n                      return result.value;\n                    }),\n                    finished: results.every(function (result) {\n                      return result.finished;\n                    })\n                  });\n\n                case 4:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }))();\n      },\n      stop: function stop(keys) {\n        return shared.each(getControllers(), function (ctrl) {\n          return ctrl.stop(keys);\n        });\n      },\n      pause: function pause(keys) {\n        return shared.each(getControllers(), function (ctrl) {\n          return ctrl.pause(keys);\n        });\n      },\n      resume: function resume(keys) {\n        return shared.each(getControllers(), function (ctrl) {\n          return ctrl.resume(keys);\n        });\n      }\n    };\n  }\n};\n/** @internal */\n\nfunction useSprings(length, props, deps) {\n  var propsFn = shared.is.fun(props) && props;\n  if (propsFn && !deps) deps = []; // Set to 0 to prevent sync flush.\n\n  var layoutId = React.useRef(0);\n  var forceUpdate = shared.useForceUpdate(); // State is updated on commit.\n\n  var _useState = React.useState(function () {\n    return {\n      ctrls: [],\n      queue: [],\n      flush: function flush(ctrl, updates) {\n        var springs = getSprings(ctrl, updates); // Flushing is postponed until the component's commit phase\n        // if a spring was created since the last commit.\n\n        var canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs).some(function (key) {\n          return !ctrl.springs[key];\n        });\n        return canFlushSync ? flushUpdateQueue(ctrl, updates) : new Promise(function (resolve) {\n          setSprings(ctrl, springs);\n          state.queue.push(function () {\n            resolve(flushUpdateQueue(ctrl, updates));\n          });\n          forceUpdate();\n        });\n      }\n    };\n  }),\n      state = _useState[0]; // The imperative API ref from the props of the first controller.\n\n\n  var refProp = React.useRef();\n  var ctrls = [].concat(state.ctrls);\n  var updates = []; // Cache old controllers to dispose in the commit phase.\n\n  var prevLength = shared.usePrev(length) || 0;\n  var disposed = ctrls.slice(length, prevLength); // Create new controllers when \"length\" increases, and destroy\n  // the affected controllers when \"length\" decreases.\n\n  useMemo(function () {\n    ctrls.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]); // Update existing controllers when \"deps\" are changed.\n\n  useMemo(function () {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n  /** Fill the `updates` array with declarative updates for the given index range. */\n\n  function declareUpdates(startIndex, endIndex) {\n    for (var _i = startIndex; _i < endIndex; _i++) {\n      var _ctrl = ctrls[_i] || (ctrls[_i] = new Controller(null, state.flush));\n\n      var update = propsFn ? propsFn(_i, _ctrl) : props[_i];\n\n      if (update) {\n        update = updates[_i] = declareUpdate(update);\n\n        if (_i == 0) {\n          refProp.current = update.ref;\n          update.ref = undefined;\n        }\n      }\n    }\n  }\n\n  var api = React.useMemo(function () {\n    return SpringHandle.create(function () {\n      return state.ctrls;\n    });\n  }, []); // New springs are created during render so users can pass them to\n  // their animated components, but new springs aren't cached until the\n  // commit phase (see the `useLayoutEffect` callback below).\n\n  var springs = ctrls.map(function (ctrl, i) {\n    return getSprings(ctrl, updates[i]);\n  });\n  var context = useSpringContext();\n  reactLayoutEffect.useLayoutEffect(function () {\n    layoutId.current++; // Replace the cached controllers.\n\n    state.ctrls = ctrls; // Update the ref prop.\n\n    if (refProp.current) {\n      refProp.current.current = api;\n    } // Flush the commit queue.\n\n\n    var queue = state.queue;\n\n    if (queue.length) {\n      state.queue = [];\n      shared.each(queue, function (cb) {\n        return cb();\n      });\n    } // Dispose unused controllers.\n\n\n    shared.each(disposed, function (ctrl) {\n      return ctrl.dispose();\n    }); // Update existing controllers.\n\n    shared.each(ctrls, function (ctrl, i) {\n      var values = springs[i];\n      setSprings(ctrl, values); // Update the default props.\n\n      ctrl.start({\n        \"default\": context\n      }); // Apply updates created during render.\n\n      var update = updates[i];\n\n      if (update) {\n        // Start animating unless a ref exists.\n        if (refProp.current) {\n          ctrl.queue.push(update);\n        } else {\n          ctrl.start(update);\n        }\n      }\n    });\n  }); // Dispose all controllers on unmount.\n\n  shared.useOnce(function () {\n    return function () {\n      shared.each(state.ctrls, function (ctrl) {\n        return ctrl.dispose();\n      });\n    };\n  }); // Return a deep copy of the `springs` array so the caller can\n  // safely mutate it during render.\n\n  var values = springs.map(function (x) {\n    return _extends({}, x);\n  });\n  return propsFn || arguments.length == 3 ? [values, api.start, api.stop] : values;\n}\n/**\n * The props that `useSpring` recognizes.\n */\n\n/** @internal */\n\n\nfunction useSpring(props, deps) {\n  var isFn = shared.is.fun(props);\n\n  var _useSprings = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps),\n      _useSprings$ = _useSprings[0],\n      values = _useSprings$[0],\n      update = _useSprings[1],\n      stop = _useSprings[2];\n\n  return isFn || arguments.length == 2 ? [values, update, stop] : values;\n}\n\nfunction useTrail(length, propsArg, deps) {\n  var propsFn = shared.is.fun(propsArg) && propsArg;\n  if (propsFn && !deps) deps = [];\n  var ctrls = [];\n  var result = useSprings(length, function (i, ctrl) {\n    ctrls[i] = ctrl;\n    return getProps(propsArg, i, ctrl);\n  }, // Ensure the props function is called when no deps exist.\n  // This works around the 3 argument rule.\n  deps || [{}]);\n  reactLayoutEffect.useLayoutEffect(function () {\n    var reverse = shared.is.obj(propsArg) && propsArg.reverse;\n\n    for (var _i = 0; _i < ctrls.length; _i++) {\n      var parent = ctrls[_i + (reverse ? 1 : -1)];\n      if (parent) ctrls[_i].update({\n        to: parent.springs\n      }).start();\n    }\n  }, deps);\n\n  if (propsFn || arguments.length == 3) {\n    var update = result[1];\n    result[1] = useMemoOne.useCallbackOne(function (propsArg) {\n      var reverse = shared.is.obj(propsArg) && propsArg.reverse;\n      return update(function (i, ctrl) {\n        var props = getProps(propsArg, i, ctrl);\n        var parent = ctrls[i + (reverse ? 1 : -1)];\n        if (parent) props.to = parent.springs;\n        return props;\n      });\n    }, deps);\n    return result;\n  }\n\n  return result[0];\n} // TODO: convert to \"const enum\" once Babel supports it\n\n/** This transition is being mounted */\n\n\nvar MOUNT = 'mount';\n/** This transition is entering or has entered */\n\nvar ENTER = 'enter';\n/** This transition had its animations updated */\n\nvar UPDATE = 'update';\n/** This transition will expire after animating */\n\nvar LEAVE = 'leave';\n\nfunction useTransition(data, props, deps) {\n  var ref = props.ref,\n      reset = props.reset,\n      sort = props.sort,\n      _props$trail = props.trail,\n      trail = _props$trail === void 0 ? 0 : _props$trail,\n      _props$expires = props.expires,\n      expires = _props$expires === void 0 ? true : _props$expires; // Every item has its own transition.\n\n  var items = shared.toArray(data);\n  var transitions = []; // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n\n  var keys = getKeys(items, props); // The \"onRest\" callbacks need a ref to the latest transitions.\n\n  var usedTransitions = React.useRef(null);\n  var prevTransitions = reset ? null : usedTransitions.current;\n  reactLayoutEffect.useLayoutEffect(function () {\n    usedTransitions.current = transitions;\n  }); // Destroy all transitions on dismount.\n\n  shared.useOnce(function () {\n    return function () {\n      return shared.each(usedTransitions.current, function (t) {\n        if (t.expired) {\n          clearTimeout(t.expirationId);\n        }\n\n        t.ctrl.dispose();\n      });\n    };\n  }); // Map old indices to new indices.\n\n  var reused = [];\n  if (prevTransitions) shared.each(prevTransitions, function (t, i) {\n    // Expired transitions are not rendered.\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  }); // Mount new items with fresh transitions.\n\n  shared.each(items, function (item, i) {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item: item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  }); // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n\n  if (reused.length) {\n    var i = -1;\n    shared.each(reused, function (keyIndex, prevIndex) {\n      var t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends(_extends({}, t), {}, {\n          item: items[keyIndex]\n        });\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (shared.is.fun(sort)) {\n    transitions.sort(function (a, b) {\n      return sort(a.item, b.item);\n    });\n  } // Track cumulative delay for the \"trail\" prop.\n\n\n  var delay = -trail; // Expired transitions use this to dismount.\n\n  var forceUpdate = shared.useForceUpdate(); // These props are inherited by every phase change.\n\n  var defaultProps = getDefaultProps(props); // Generate changes to apply in useEffect.\n\n  var changes = new Map();\n  shared.each(transitions, function (t, i) {\n    var key = t.key;\n    var prevPhase = t.phase;\n    var to;\n    var phase;\n\n    if (prevPhase == MOUNT) {\n      to = props.enter;\n      phase = ENTER;\n    } else {\n      var isLeave = keys.indexOf(key) < 0;\n\n      if (prevPhase != LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    } // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n    // (2) an async function, or (3) an object with any \"useSpring\" props.\n\n\n    to = callProp(to, t.item, i);\n    to = shared.is.obj(to) ? inferTo(to) : {\n      to: to\n    };\n\n    if (!to.config) {\n      var config = props.config || defaultProps.config;\n      to.config = callProp(config, t.item, i);\n    } // The payload is used to update the spring props once the current render is committed.\n\n\n    var payload = _extends(_extends({}, defaultProps), {}, {\n      delay: delay += trail,\n      // This prevents implied resets.\n      reset: false\n    }, to);\n\n    if (phase == ENTER && shared.is.und(payload.from)) {\n      // The `initial` prop is used on the first render of our parent component,\n      // as well as when `reset: true` is passed. It overrides the `from` prop\n      // when defined, and it makes `enter` instant when null.\n      var from = shared.is.und(props.initial) || prevTransitions ? props.from : props.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n\n    var onRest = payload.onRest;\n\n    payload.onRest = function (result) {\n      var transitions = usedTransitions.current;\n      var t = transitions.find(function (t) {\n        return t.key === key;\n      });\n      if (!t) return;\n\n      if (shared.is.fun(onRest)) {\n        onRest(result, t);\n      } // Reset the phase of a cancelled enter/leave transition, so it can\n      // retry the animation on the next render.\n\n\n      if (result.cancelled && t.phase != UPDATE) {\n        t.phase = prevPhase;\n        return;\n      }\n\n      if (t.ctrl.idle) {\n        var idle = transitions.every(function (t) {\n          return t.ctrl.idle;\n        });\n\n        if (t.phase == LEAVE) {\n          var expiry = callProp(expires, t.item);\n\n          if (expiry !== false) {\n            var expiryMs = expiry === true ? 0 : expiry;\n            t.expired = true; // Force update once the expiration delay ends.\n\n            if (!idle && expiryMs > 0) {\n              // The maximum timeout is 2^31-1\n              if (expiryMs <= 0x7fffffff) t.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        } // Force update once idle and expired items exist.\n\n\n        if (idle && transitions.some(function (t) {\n          return t.expired;\n        })) {\n          forceUpdate();\n        }\n      }\n    };\n\n    var springs = getSprings(t.ctrl, payload);\n    changes.set(t, {\n      phase: phase,\n      springs: springs,\n      payload: payload\n    });\n  }); // The prop overrides from an ancestor.\n\n  var context = useSpringContext(); // Merge the context into each transition.\n\n  reactLayoutEffect.useLayoutEffect(function () {\n    shared.each(transitions, function (t) {\n      t.ctrl.start({\n        \"default\": context\n      });\n    });\n  }, [context]);\n  var api = React.useMemo(function () {\n    return SpringHandle.create(function () {\n      return usedTransitions.current.map(function (t) {\n        return t.ctrl;\n      });\n    });\n  }, []);\n  React.useImperativeHandle(ref, function () {\n    return api;\n  });\n  reactLayoutEffect.useLayoutEffect(function () {\n    shared.each(changes, function (_ref, t) {\n      var phase = _ref.phase,\n          springs = _ref.springs,\n          payload = _ref.payload;\n      setSprings(t.ctrl, springs);\n\n      if (!context.cancel) {\n        t.phase = phase;\n\n        if (phase == ENTER) {\n          t.ctrl.start({\n            \"default\": context\n          });\n        }\n\n        t.ctrl[ref ? 'update' : 'start'](payload);\n      }\n    });\n  }, reset ? void 0 : deps);\n\n  var renderTransitions = function renderTransitions(render) {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, transitions.map(function (t, i) {\n      var _ref2 = changes.get(t) || t.ctrl,\n          springs = _ref2.springs;\n\n      var elem = render(_extends({}, springs), t.item, t, i);\n      return elem && elem.type ? /*#__PURE__*/React.createElement(elem.type, _extends({}, elem.props, {\n        key: shared.is.str(t.key) || shared.is.num(t.key) ? t.key : t.ctrl.id,\n        ref: elem.ref\n      })) : elem;\n    }));\n  };\n\n  return arguments.length == 3 ? [renderTransitions, api.start, api.stop] : renderTransitions;\n}\n\nfunction getKeys(items, _ref3) {\n  var key = _ref3.key,\n      _ref3$keys = _ref3.keys,\n      keys = _ref3$keys === void 0 ? key : _ref3$keys;\n  return shared.is.und(keys) ? items : shared.is.fun(keys) ? items.map(keys) : shared.toArray(keys);\n}\n/**\n * The `Spring` component passes `SpringValue` objects to your render prop.\n */\n\n\nfunction Spring(_ref) {\n  var children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return children(useSpring(props));\n}\n\nfunction Trail(_ref) {\n  var items = _ref.items,\n      children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n\n  var trails = useTrail(items.length, props);\n  return items.map(function (item, index) {\n    var result = children(item, index);\n    return shared.is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition(_ref) {\n  var items = _ref.items,\n      children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, useTransition(items, props)(children));\n}\n/**\n * An `Interpolation` is a memoized value that's computed whenever one of its\n * `FluidValue` dependencies has its value changed.\n *\n * Other `FrameValue` objects can depend on this. For example, passing an\n * `Interpolation` as the `to` prop of a `useSpring` call will trigger an\n * animation toward the memoized value.\n */\n\n\nvar Interpolation = /*#__PURE__*/function (_FrameValue) {\n  _inheritsLoose(Interpolation, _FrameValue);\n  /** Useful for debugging. */\n\n  /** Equals false when in the frameloop */\n\n  /** The function that maps inputs values to output */\n\n\n  function Interpolation(source, args) {\n    var _this;\n\n    _this = _FrameValue.call(this) || this;\n    _this.source = source;\n    _this.key = void 0;\n    _this.idle = true;\n    _this.calc = void 0;\n    _this.calc = shared.createInterpolator.apply(void 0, args);\n\n    var value = _this._get();\n\n    var nodeType = shared.is.arr(value) ? animated.AnimatedArray : animated.AnimatedValue; // Assume the computed value never changes type.\n\n    animated.setAnimated(_assertThisInitialized(_this), nodeType.create(value));\n    return _this;\n  }\n\n  var _proto = Interpolation.prototype;\n\n  _proto.advance = function advance(_dt) {\n    var value = this._get();\n\n    var oldValue = this.get();\n\n    if (!shared.isEqual(value, oldValue)) {\n      animated.getAnimated(this).setValue(value);\n\n      this._onChange(value, this.idle);\n    }\n  };\n\n  _proto._get = function _get() {\n    var inputs = shared.is.arr(this.source) ? this.source.map(function (node) {\n      return node.get();\n    }) : shared.toArray(this.source.get());\n    return this.calc.apply(this, inputs);\n  };\n\n  _proto._reset = function _reset() {\n    shared.each(animated.getPayload(this), function (node) {\n      return node.reset();\n    });\n\n    _FrameValue.prototype._reset.call(this);\n  };\n\n  _proto._start = function _start() {\n    this.idle = false;\n\n    _FrameValue.prototype._start.call(this);\n\n    if (G.skipAnimation) {\n      this.idle = true;\n      this.advance();\n    } else {\n      G.frameLoop.start(this);\n    }\n  };\n\n  _proto._attach = function _attach() {\n    var _this2 = this; // Start observing our \"source\" once we have an observer.\n\n\n    var idle = true;\n    var priority = 1;\n    shared.each(shared.toArray(this.source), function (source) {\n      if (isFrameValue(source)) {\n        if (!source.idle) idle = false;\n        priority = Math.max(priority, source.priority + 1);\n      }\n\n      source.addChild(_this2);\n    });\n    this.priority = priority;\n\n    if (!idle) {\n      this._reset();\n\n      this._start();\n    }\n  };\n\n  _proto._detach = function _detach() {\n    var _this3 = this; // Stop observing our \"source\" once we have no observers.\n\n\n    shared.each(shared.toArray(this.source), function (source) {\n      source.removeChild(_this3);\n    }); // This removes us from the frameloop.\n\n    this.idle = true;\n  }\n  /** @internal */\n  ;\n\n  _proto.onParentChange = function onParentChange(event) {\n    // Ensure our start value respects our parent values, in case\n    // any of their animations were restarted with the \"reset\" prop.\n    if (event.type == 'start') {\n      this.advance();\n    } // Change events are useful for (1) reacting to non-animated parents\n    // and (2) reacting to the last change in a parent animation.\n    else if (event.type == 'change') {\n        // If we're idle, we know for sure that this change is *not*\n        // caused by an animation.\n        if (this.idle) {\n          this.advance();\n        } // Leave the frameloop when all parents are done animating.\n        else if (event.idle) {\n            this.idle = shared.toArray(this.source).every(function (source) {\n              return source.idle !== false;\n            });\n\n            if (this.idle) {\n              this.advance();\n              shared.each(animated.getPayload(this), function (node) {\n                node.done = true;\n              });\n            }\n          }\n      } // Ensure our priority is greater than all parents, which means\n      // our value won't be updated until our parents have updated.\n      else if (event.type == 'priority') {\n          this.priority = shared.toArray(this.source).reduce(function (max, source) {\n            return Math.max(max, (source.priority || 0) + 1);\n          }, 0);\n        }\n\n    _FrameValue.prototype.onParentChange.call(this, event);\n  };\n\n  return Interpolation;\n}(FrameValue);\n/** Map the value of one or more dependencies */\n\n\nvar to = function to(source) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return new Interpolation(source, args);\n};\n/** @deprecated Use the `to` export instead */\n\n\nvar interpolate = function interpolate(source) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  return deprecations.deprecateInterpolate(), new Interpolation(source, args);\n};\n/** Extract the raw value types that are being interpolated */\n\n\nshared.Globals.assign({\n  createStringInterpolator: stringInterpolation.createStringInterpolator,\n  to: function to(source, args) {\n    return new Interpolation(source, args);\n  }\n});\n/** Advance all animations forward one frame */\n\nvar update = function update() {\n  return shared.Globals.frameLoop.advance();\n};\n\nObject.keys(types).forEach(function (k) {\n  if (k !== 'default') Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () {\n      return types[k];\n    }\n  });\n});\nObject.defineProperty(exports, 'FrameLoop', {\n  enumerable: true,\n  get: function () {\n    return shared.FrameLoop;\n  }\n});\nObject.defineProperty(exports, 'Globals', {\n  enumerable: true,\n  get: function () {\n    return shared.Globals;\n  }\n});\nObject.defineProperty(exports, 'createInterpolator', {\n  enumerable: true,\n  get: function () {\n    return shared.createInterpolator;\n  }\n});\nexports.BailSignal = BailSignal;\nexports.Controller = Controller;\nexports.FrameValue = FrameValue;\nexports.Interpolation = Interpolation;\nexports.Spring = Spring;\nexports.SpringContext = SpringContext;\nexports.SpringHandle = SpringHandle;\nexports.SpringValue = SpringValue;\nexports.Trail = Trail;\nexports.Transition = Transition;\nexports.config = config;\nexports.inferTo = inferTo;\nexports.interpolate = interpolate;\nexports.to = to;\nexports.update = update;\nexports.useChain = useChain;\nexports.useSpring = useSpring;\nexports.useSprings = useSprings;\nexports.useTrail = useTrail;\nexports.useTransition = useTransition;","map":{"version":3,"sources":["src/hooks/useChain.js","src/constants.ts","src/AnimationConfig.ts","src/Animation.ts","src/helpers.ts","src/scheduleProps.ts","src/AnimationResult.ts","src/runAsync.ts","src/FrameValue.ts","src/SpringPhase.ts","src/SpringValue.ts","src/Controller.ts","src/SpringContext.tsx","src/SpringHandle.ts","src/hooks/useSprings.ts","src/hooks/useSpring.ts","src/hooks/useTrail.ts","src/TransitionPhase.ts","src/hooks/useTransition.tsx","src/components/Spring.tsx","src/components/Trail.tsx","src/components/Transition.tsx","src/Interpolation.ts","src/interpolate.ts","src/globals.ts"],"names":["timeFrame","useLayoutEffect","prevDelay","each","ref","controllers","delay","timeSteps","isNaN","ctrl","props","p","Promise","start","updates","q","config","tension","friction","gentle","wobbly","stiff","slow","molasses","linear","defaults","configs","mass","damping","easing","clamp","AnimationConfig","frequency","velocity","restVelocity","precision","progress","duration","bounce","decay","round","Object","defaultConfig","sanitizeConfig","newConfig","is","Math","isTensionConfig","emptyArray","Animation","useMemo","useMemoOne","deps","args","value","matchProp","key","toArray","getProps","hasDefaultProp","getDefaultProp","getDefaultProps","omitKeys","keys","mergeDefaultProps","DEFAULT_PROPS","RESERVED_PROPS","from","to","loop","reset","pause","cancel","reverse","immediate","onDelayEnd","onProps","onStart","onChange","onRest","items","trail","sort","expires","initial","enter","update","leave","children","callId","parentId","forward","count","getForwardProps","out","getFluidConfig","computeGoal","range","output","state","actions","callProp","onResume","timeout","G","reject","getCombinedResult","results","result","getCancelledResult","getNoopResult","getFinishedResult","target","noop","finished","cancelled","prevTo","prevPromise","defaultProps","bailPromise","preventBail","bail","withBailHandler","onError","err","fn","bailIfEnded","bailResult","bailSignal","animate","arg1","animating","BailSignal","isFrameValue","nextId","FrameValue","FluidValue","get","node","getAnimated","interpolate","deprecateInterpolate","addChild","removeChild","onParentChange","type","parent","idle","priority","Array","child","CREATED","IDLE","ACTIVE","PAUSED","DISPOSED","SpringValue","animation","queue","_phase","_state","pauseQueue","resumeQueue","_defaultProps","_lastCallId","_lastToId","getFluidValue","AnimatedValue","advance","changed","anim","toValues","payload","getPayload","toConfig","position","elapsed","v0","e","bounceFactor","canBounce","isGrowing","isBouncing","step","numSteps","dt","n","isMoving","springForce","dampingForce","acceleration","Number","console","set","checkDisposed","flush","onPause","resume","finish","stop","cancelAsync","dispose","event","nodeType","setAnimated","parentNode","AnimatedArray","isAnimatedString","AnimatedString","mergeDefaultProp","isLoop","nextProps","createLoopUpdate","resolve","hasToProp","hasFromProp","coerceEventProp","prevFrom","hasFromChanged","isEqual","hasToChanged","fromConfig","hasAsyncTo","mergeConfig","goal","isAnimatable","Error","goalType","started","hasValueChanged","onRestQueue","checkFinishedOnRest","onRestIndex","runAsync","oldValue","spring","prop","loopRet","overrides","inferTo","createUpdate","findDefined","BATCHED_EVENTS","Controller","id","springs","_flush","_initialProps","_lastAsyncId","_active","_events","values","prepareKeys","flushUpdateQueue","isActive","flushUpdate","asyncTo","handler","promises","scheduleProps","undefined","prepareSprings","createSpring","create","ctx","React","SpringContext","inherited","useContext","Provider","useSpringContext","SpringHandle","getControllers","propsFn","layoutId","useRef","forceUpdate","useForceUpdate","useState","ctrls","getSprings","canFlushSync","setSprings","refProp","prevLength","usePrev","disposed","declareUpdates","i","declareUpdate","api","context","cb","useOnce","arguments","isFn","useSprings","propsArg","useCallbackOne","MOUNT","ENTER","UPDATE","LEAVE","transitions","getKeys","usedTransitions","prevTransitions","t","clearTimeout","reused","item","phase","a","b","changes","prevPhase","isLeave","expiry","expiryMs","setTimeout","useImperativeHandle","renderTransitions","elem","render","useSpring","trails","useTrail","React.createElement","useTransition","Interpolation","calc","source","createInterpolator","inputs","Globals","createStringInterpolator"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar reactLayoutEffect = require('react-layout-effect');\nvar shared = require('@react-spring/shared');\nvar _extends = _interopDefault(require('@babel/runtime/helpers/extends'));\nvar React = require('react');\nvar _regeneratorRuntime = _interopDefault(require('@babel/runtime/regenerator'));\nvar _asyncToGenerator = _interopDefault(require('@babel/runtime/helpers/asyncToGenerator'));\nvar _createClass = _interopDefault(require('@babel/runtime/helpers/createClass'));\nvar _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));\nvar animated = require('@react-spring/animated/index.cjs.js');\nvar G = require('@react-spring/shared/globals');\nvar useMemoOne = require('use-memo-one');\nvar _wrapNativeSuper = _interopDefault(require('@babel/runtime/helpers/wrapNativeSuper'));\nvar deprecations = require('@react-spring/shared/deprecations');\nvar _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));\nvar _assertThisInitialized = _interopDefault(require('@babel/runtime/helpers/assertThisInitialized'));\nvar stringInterpolation = require('@react-spring/shared/stringInterpolation');\nvar types = require('@react-spring/shared/types');\n\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nfunction useChain(refs, timeSteps, timeFrame) {\n  if (timeFrame === void 0) {\n    timeFrame = 1000;\n  }\n\n  reactLayoutEffect.useLayoutEffect(function () {\n    if (timeSteps) {\n      var prevDelay = 0;\n      shared.each(refs, function (ref, i) {\n        if (!ref.current) return;\n        var controllers = ref.current.controllers;\n\n        if (controllers.length) {\n          var delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          shared.each(controllers, function (ctrl) {\n            shared.each(ctrl.queue, function (props) {\n              props.delay = delay + (props.delay || 0);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      var p = Promise.resolve();\n      shared.each(refs, function (ref) {\n        var _ref = ref.current || {},\n            controllers = _ref.controllers,\n            start = _ref.start;\n\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          var updates = controllers.map(function (ctrl) {\n            var q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(function () {\n            shared.each(controllers, function (ctrl, i) {\n              var _ctrl$queue;\n\n              return (_ctrl$queue = ctrl.queue).push.apply(_ctrl$queue, updates[i]);\n            });\n            return start();\n          });\n        }\n      });\n    }\n  });\n}\n\n// The `mass` prop defaults to 1\nvar config = {\n  \"default\": {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nvar linear = function linear(t) {\n  return t;\n};\n\nvar defaults = _extends(_extends({}, config[\"default\"]), {}, {\n  mass: 1,\n  damping: 1,\n  easing: linear,\n  clamp: false\n});\n\nvar AnimationConfig =\n/**\n * With higher tension, the spring will resist bouncing and try harder to stop at its end value.\n *\n * When tension is zero, no animation occurs.\n */\n\n/**\n * The damping ratio coefficient, or just the damping ratio when `speed` is defined.\n *\n * When `speed` is defined, this value should be between 0 and 1.\n *\n * Higher friction means the spring will slow down faster.\n */\n\n/**\n * The natural frequency (in seconds), which dictates the number of bounces\n * per second when no damping exists.\n *\n * When defined, `tension` is derived from this, and `friction` is derived\n * from `tension` and `damping`.\n */\n\n/**\n * The damping ratio, which dictates how the spring slows down.\n *\n * Set to `0` to never slow down. Set to `1` to slow down without bouncing.\n * Between `0` and `1` is for you to explore.\n *\n * Only works when `frequency` is defined.\n *\n * Defaults to 1\n */\n\n/**\n * Higher mass means more friction is required to slow down.\n *\n * Defaults to 1, which works fine most of the time.\n */\n\n/**\n * The initial velocity of one or more values.\n */\n\n/**\n * The smallest velocity before the animation is considered \"not moving\".\n *\n * When undefined, `precision` is used instead.\n */\n\n/**\n * The smallest distance from a value before that distance is essentially zero.\n *\n * This helps in deciding when a spring is \"at rest\". The spring must be within\n * this distance from its final value, and its velocity must be lower than this\n * value too (unless `restVelocity` is defined).\n */\n\n/**\n * For `duration` animations only. Note: The `duration` is not affected\n * by this property.\n *\n * Defaults to `0`, which means \"start from the beginning\".\n *\n * Setting to `1+` makes an immediate animation.\n *\n * Setting to `0.5` means \"start from the middle of the easing function\".\n *\n * Any number `>= 0` and `<= 1` makes sense here.\n */\n\n/**\n * Animation length in number of milliseconds.\n */\n\n/**\n * The animation curve. Only used when `duration` is defined.\n *\n * Defaults to quadratic ease-in-out.\n */\n\n/**\n * Avoid overshooting by ending abruptly at the goal value.\n */\n\n/**\n * When above zero, the spring will bounce instead of overshooting when\n * exceeding its goal value. Its velocity is multiplied by `-1 + bounce`\n * whenever its current value equals or exceeds its goal. For example,\n * setting `bounce` to `0.5` chops the velocity in half on each bounce,\n * in addition to any friction.\n */\n\n/**\n * \"Decay animations\" decelerate without an explicit goal value.\n * Useful for scrolling animations.\n *\n * Use `true` for the default exponential decay factor (`0.998`).\n *\n * When a `number` between `0` and `1` is given, a lower number makes the\n * animation slow down faster. And setting to `1` would make an unending\n * animation.\n */\n\n/**\n * While animating, round to the nearest multiple of this number.\n * The `from` and `to` values are never rounded, as well as any value\n * passed to the `set` method of an animated value.\n */\nfunction AnimationConfig() {\n  this.tension = void 0;\n  this.friction = void 0;\n  this.frequency = void 0;\n  this.damping = void 0;\n  this.mass = void 0;\n  this.velocity = 0;\n  this.restVelocity = void 0;\n  this.precision = void 0;\n  this.progress = void 0;\n  this.duration = void 0;\n  this.easing = void 0;\n  this.clamp = void 0;\n  this.bounce = void 0;\n  this.decay = void 0;\n  this.round = void 0;\n  Object.assign(this, defaults);\n};\nfunction mergeConfig(config, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = _extends({}, defaultConfig);\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = _extends(_extends({}, defaultConfig), newConfig);\n  }\n\n  sanitizeConfig(config, newConfig);\n  Object.assign(config, newConfig);\n\n  for (var key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key];\n    }\n  }\n\n  var mass = config.mass,\n      frequency = config.frequency,\n      damping = config.damping;\n\n  if (!shared.is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01;\n    if (damping < 0) damping = 0;\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n\n  return config;\n} // Prevent a config from accidentally overriding new props.\n// This depends on which \"config\" props take precedence when defined.\n\nfunction sanitizeConfig(config, props) {\n  if (!shared.is.und(props.decay)) {\n    config.duration = undefined;\n  } else {\n    var isTensionConfig = !shared.is.und(props.tension) || !shared.is.und(props.friction);\n\n    if (isTensionConfig || !shared.is.und(props.frequency) || !shared.is.und(props.damping) || !shared.is.und(props.mass)) {\n      config.duration = undefined;\n      config.decay = undefined;\n    }\n\n    if (isTensionConfig) {\n      config.frequency = undefined;\n    }\n  }\n}\n\nvar emptyArray = [];\n/** @internal */\n\n/** An animation being executed by the frameloop */\nvar Animation = function Animation() {\n  this.changed = false;\n  this.values = emptyArray;\n  this.toValues = null;\n  this.fromValues = emptyArray;\n  this.to = void 0;\n  this.from = void 0;\n  this.config = new AnimationConfig();\n  this.immediate = false;\n  this.onStart = void 0;\n  this.onChange = void 0;\n  this.onRest = [];\n};\n\nfunction _createForOfIteratorHelperLoose(o) { var i = 0; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } i = o[Symbol.iterator](); return i.next.bind(i); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n// @see https://github.com/alexreardon/use-memo-one/pull/10\nvar useMemo = function useMemo(create, deps) {\n  return useMemoOne.useMemoOne(create, deps || [{}]);\n};\nfunction callProp(value) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return shared.is.fun(value) ? value.apply(void 0, args) : value;\n}\n/** Try to coerce the given value into a boolean using the given key */\n\nvar matchProp = function matchProp(value, key) {\n  return value === true || !!(key && value && (shared.is.fun(value) ? value(key) : shared.toArray(value).includes(key)));\n};\nvar getProps = function getProps(props, i, arg) {\n  return props && (shared.is.fun(props) ? props(i, arg) : shared.is.arr(props) ? props[i] : _extends({}, props));\n};\n/** Returns `true` if the given prop is having its default value set. */\n\nvar hasDefaultProp = function hasDefaultProp(props, key) {\n  return !shared.is.und(getDefaultProp(props, key));\n};\n/** Get the default value being set for the given `key` */\n\nvar getDefaultProp = function getDefaultProp(props, key) {\n  return props[\"default\"] === true ? props[key] : props[\"default\"] ? props[\"default\"][key] : undefined;\n};\n/**\n * Extract the default props from an update.\n *\n * When the `default` prop is falsy, this function still behaves as if\n * `default: true` was used. The `default` prop is always respected when\n * truthy.\n */\n\nvar getDefaultProps = function getDefaultProps(props, omitKeys, defaults) {\n  if (omitKeys === void 0) {\n    omitKeys = [];\n  }\n\n  if (defaults === void 0) {\n    defaults = {};\n  }\n\n  var keys = DEFAULT_PROPS;\n\n  if (props[\"default\"] && props[\"default\"] !== true) {\n    props = props[\"default\"];\n    keys = Object.keys(props);\n  }\n\n  for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {\n    var key = _step.value;\n    var value = props[key];\n\n    if (!shared.is.und(value) && !omitKeys.includes(key)) {\n      defaults[key] = value;\n    }\n  }\n\n  return defaults;\n};\n/** Merge the default props of an update into a props cache. */\n\nvar mergeDefaultProps = function mergeDefaultProps(defaults, props, omitKeys) {\n  return getDefaultProps(props, omitKeys, defaults);\n};\n/** These props can have default values */\n\nvar DEFAULT_PROPS = ['pause', 'cancel', 'config', 'immediate', 'onDelayEnd', 'onProps', 'onStart', 'onChange', 'onRest'];\nvar RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  \"default\": 1,\n  delay: 1,\n  onDelayEnd: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onRest: 1,\n  // Transition props\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  // Internal props\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\n/**\n * Extract any properties whose keys are *not* reserved for customizing your\n * animations. All hooks use this function, which means `useTransition` props\n * are reserved for `useSpring` calls, etc.\n */\n\nfunction getForwardProps(props) {\n  var forward = {};\n  var count = 0;\n  shared.each(props, function (value, prop) {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n\n  if (count) {\n    return forward;\n  }\n}\n/**\n * Clone the given `props` and move all non-reserved props\n * into the `to` prop.\n */\n\n\nfunction inferTo(props) {\n  var to = getForwardProps(props);\n\n  if (to) {\n    var out = {\n      to: to\n    };\n    shared.each(props, function (val, key) {\n      return key in to || (out[key] = val);\n    });\n    return out;\n  }\n\n  return _extends({}, props);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\nfunction computeGoal(value) {\n  var config = shared.getFluidConfig(value);\n  return config ? computeGoal(config.get()) : shared.is.arr(value) ? value.map(computeGoal) : shared.isAnimatedString(value) ? G.createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n\n/**\n * This function sets a timeout if both the `delay` prop exists and\n * the `cancel` prop is not `true`.\n *\n * The `actions.start` function must handle the `cancel` prop itself,\n * but the `pause` prop is taken care of.\n */\nfunction scheduleProps(callId, _ref) {\n  var key = _ref.key,\n      props = _ref.props,\n      state = _ref.state,\n      actions = _ref.actions;\n  return new Promise(function (resolve, reject) {\n    var delay;\n    var timeout;\n    var pause = false;\n    var cancel = matchProp(props.cancel, key);\n\n    if (cancel) {\n      onStart();\n    } else {\n      delay = callProp(props.delay || 0, key);\n      pause = matchProp(props.pause, key);\n\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      timeout.cancel(); // Cache the remaining delay.\n\n      delay = timeout.time - shared.Globals.now();\n    }\n\n    function onResume() {\n      if (delay > 0) {\n        state.pauseQueue.add(onPause);\n        timeout = shared.Globals.frameLoop.setTimeout(onStart, delay);\n      } else {\n        onStart();\n      }\n    }\n\n    function onStart() {\n      state.pauseQueue[\"delete\"](onPause); // Maybe cancelled during its delay.\n\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n\n      try {\n        actions.start(_extends(_extends({}, props), {}, {\n          callId: callId,\n          delay: delay,\n          cancel: cancel,\n          pause: pause\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n\n/** @internal */\n\n/** The object given to the `onRest` prop and `start` promise. */\n\n/** The promised result of an animation. */\n\n/** @internal */\nvar getCombinedResult = function getCombinedResult(target, results) {\n  return results.length == 1 ? results[0] : results.some(function (result) {\n    return result.cancelled;\n  }) ? getCancelledResult(target) : results.every(function (result) {\n    return result.noop;\n  }) ? getNoopResult(target) : getFinishedResult(target, results.every(function (result) {\n    return result.finished;\n  }));\n};\n/** No-op results are for updates that never start an animation. */\n\nvar getNoopResult = function getNoopResult(target, value) {\n  if (value === void 0) {\n    value = target.get();\n  }\n\n  return {\n    value: value,\n    noop: true,\n    finished: true,\n    target: target\n  };\n};\nvar getFinishedResult = function getFinishedResult(target, finished, value) {\n  if (value === void 0) {\n    value = target.get();\n  }\n\n  return {\n    value: value,\n    finished: finished,\n    target: target\n  };\n};\nvar getCancelledResult = function getCancelledResult(target, value) {\n  if (value === void 0) {\n    value = target.get();\n  }\n\n  return {\n    value: value,\n    cancelled: true,\n    target: target\n  };\n};\n\nfunction _createForOfIteratorHelperLoose$1(o) { var i = 0; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray$1(o))) return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } i = o[Symbol.iterator](); return i.next.bind(i); }\n\nfunction _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }\n\nfunction _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * Start an async chain or an async script.\n *\n * Always call `runAsync` in the action callback of a `scheduleProps` call.\n *\n * The `T` parameter can be a set of animated values (as an object type)\n * or a primitive type for a single animated value.\n */\nfunction runAsync(_x, _x2, _x3, _x4) {\n  return _runAsync.apply(this, arguments);\n}\n\nfunction _runAsync() {\n  _runAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(to, props, state, target) {\n    var callId, parentId, onRest, prevTo, prevPromise;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!props.pause) {\n              _context4.next = 3;\n              break;\n            }\n\n            _context4.next = 3;\n            return new Promise(function (resume) {\n              state.resumeQueue.add(resume);\n            });\n\n          case 3:\n            callId = props.callId, parentId = props.parentId, onRest = props.onRest;\n            prevTo = state.asyncTo, prevPromise = state.promise;\n\n            if (!(!parentId && to === prevTo && !props.reset)) {\n              _context4.next = 7;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", prevPromise);\n\n          case 7:\n            return _context4.abrupt(\"return\", state.promise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n              var defaultProps, preventBail, bail, bailPromise, withBailHandler, bailIfEnded, animate, result, animating;\n              return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      state.asyncId = callId;\n                      state.asyncTo = to; // The default props of any `animate` calls.\n\n                      defaultProps = getDefaultProps(props, [// The `onRest` prop is only called when the `runAsync` promise is resolved.\n                      'onRest']);\n                      // This promise is rejected when the animation is interrupted.\n                      bailPromise = new Promise(function (resolve, reject) {\n                        return preventBail = resolve, bail = reject;\n                      }); // Stop animating when an error is caught.\n\n                      withBailHandler = function withBailHandler(fn) {\n                        return function () {\n                          var onError = function onError(err) {\n                            if (err instanceof BailSignal) {\n                              bail(err); // Stop animating.\n                            }\n\n                            throw err;\n                          };\n\n                          try {\n                            return fn.apply(void 0, arguments)[\"catch\"](onError);\n                          } catch (err) {\n                            onError(err);\n                          }\n                        };\n                      };\n\n                      bailIfEnded = function bailIfEnded(bailSignal) {\n                        var bailResult = // The `cancel` prop or `stop` method was used.\n                        callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.\n                        callId !== state.asyncId && getFinishedResult(target, false);\n\n                        if (bailResult) {\n                          bailSignal.result = bailResult;\n                          throw bailSignal;\n                        }\n                      }; // Note: This function cannot use the `async` keyword, because we want the\n                      // `throw` statements to interrupt the caller.\n\n\n                      animate = withBailHandler(function (arg1, arg2) {\n                        var bailSignal = new BailSignal();\n                        bailIfEnded(bailSignal);\n                        var props = shared.is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n                          to: arg1\n                        });\n                        props.parentId = callId;\n                        shared.each(defaultProps, function (value, key) {\n                          if (shared.is.und(props[key])) {\n                            props[key] = value;\n                          }\n                        });\n                        return target.start(props).then( /*#__PURE__*/function () {\n                          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(result) {\n                            return _regeneratorRuntime.wrap(function _callee$(_context) {\n                              while (1) {\n                                switch (_context.prev = _context.next) {\n                                  case 0:\n                                    bailIfEnded(bailSignal);\n\n                                    if (!target.is('PAUSED')) {\n                                      _context.next = 4;\n                                      break;\n                                    }\n\n                                    _context.next = 4;\n                                    return new Promise(function (resume) {\n                                      state.resumeQueue.add(resume);\n                                    });\n\n                                  case 4:\n                                    return _context.abrupt(\"return\", result);\n\n                                  case 5:\n                                  case \"end\":\n                                    return _context.stop();\n                                }\n                              }\n                            }, _callee);\n                          }));\n\n                          return function (_x5) {\n                            return _ref2.apply(this, arguments);\n                          };\n                        }());\n                      });\n                      _context3.prev = 7;\n\n                      // Async sequence\n                      if (shared.is.arr(to)) {\n                        animating = function () {\n                          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(queue) {\n                            var _iterator, _step, _props;\n\n                            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                              while (1) {\n                                switch (_context2.prev = _context2.next) {\n                                  case 0:\n                                    _iterator = _createForOfIteratorHelperLoose$1(queue);\n\n                                  case 1:\n                                    if ((_step = _iterator()).done) {\n                                      _context2.next = 7;\n                                      break;\n                                    }\n\n                                    _props = _step.value;\n                                    _context2.next = 5;\n                                    return animate(_props);\n\n                                  case 5:\n                                    _context2.next = 1;\n                                    break;\n\n                                  case 7:\n                                  case \"end\":\n                                    return _context2.stop();\n                                }\n                              }\n                            }, _callee2);\n                          }));\n\n                          return function (_x6) {\n                            return _ref3.apply(this, arguments);\n                          };\n                        }()(to);\n                      } // Async script\n                      else if (shared.is.fun(to)) {\n                          animating = Promise.resolve(to(animate, target.stop.bind(target)));\n                        }\n\n                      _context3.next = 11;\n                      return Promise.all([animating.then(preventBail), bailPromise]);\n\n                    case 11:\n                      result = getFinishedResult(target, true); // Bail handling\n\n                      _context3.next = 21;\n                      break;\n\n                    case 14:\n                      _context3.prev = 14;\n                      _context3.t0 = _context3[\"catch\"](7);\n\n                      if (!(_context3.t0 instanceof BailSignal)) {\n                        _context3.next = 20;\n                        break;\n                      }\n\n                      result = _context3.t0.result;\n                      _context3.next = 21;\n                      break;\n\n                    case 20:\n                      throw _context3.t0;\n\n                    case 21:\n                      _context3.prev = 21;\n\n                      if (callId == state.asyncId) {\n                        state.asyncId = parentId;\n                        state.asyncTo = parentId ? prevTo : undefined;\n                        state.promise = parentId ? prevPromise : undefined;\n                      }\n\n                      return _context3.finish(21);\n\n                    case 24:\n                      if (shared.is.fun(onRest)) {\n                        G.batchedUpdates(function () {\n                          onRest(result);\n                        });\n                      }\n\n                      return _context3.abrupt(\"return\", result);\n\n                    case 26:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3, null, [[7, 14, 21, 24]]);\n            }))());\n\n          case 8:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _runAsync.apply(this, arguments);\n}\n\nfunction cancelAsync(state, callId) {\n  state.cancelId = callId;\n  state.asyncId = state.asyncTo = state.promise = undefined;\n}\n/** This error is thrown to signal an interrupted async animation. */\n\nvar BailSignal = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(BailSignal, _Error);\n\n  function BailSignal() {\n    var _this;\n\n    _this = _Error.call(this, 'An async animation has been interrupted. You see this error because you ' + 'forgot to use `await` or `.catch(...)` on its returned promise.') || this;\n    _this.result = void 0;\n    return _this;\n  }\n\n  return BailSignal;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar isFrameValue = function isFrameValue(value) {\n  return value instanceof FrameValue;\n};\nvar nextId = 1;\n/**\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\n *\n * Its underlying value can be accessed and even observed.\n */\n\nvar FrameValue = /*#__PURE__*/function (_FluidValue) {\n  _inheritsLoose(FrameValue, _FluidValue);\n\n  function FrameValue() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _FluidValue.call.apply(_FluidValue, [this].concat(args)) || this;\n    _this.id = nextId++;\n    _this.key = void 0;\n    _this._priority = 0;\n    _this._children = new Set();\n    return _this;\n  }\n\n  var _proto = FrameValue.prototype;\n\n  /** Get the current value */\n  _proto.get = function get() {\n    var node = animated.getAnimated(this);\n    return node && node.getValue();\n  }\n  /** Create a spring that maps our value to another value */\n  ;\n\n  _proto.to = function to() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return G.to(this, args);\n  }\n  /** @deprecated Use the `to` method instead. */\n  ;\n\n  _proto.interpolate = function interpolate() {\n    deprecations.deprecateInterpolate();\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return G.to(this, args);\n  }\n  /** @internal */\n  ;\n\n  /** @internal */\n  _proto.addChild = function addChild(child) {\n    if (!this._children.size) this._attach();\n\n    this._children.add(child);\n  }\n  /** @internal */\n  ;\n\n  _proto.removeChild = function removeChild(child) {\n    this._children[\"delete\"](child);\n\n    if (!this._children.size) this._detach();\n  }\n  /** @internal */\n  ;\n\n  _proto.onParentChange = function onParentChange(_ref) {\n    var type = _ref.type;\n\n    if (this.idle) {\n      // Start animating when a parent does.\n      if (type == 'start') {\n        this._reset();\n\n        this._start();\n      }\n    } // Reset our animation state when a parent does, but only when\n    // our animation is active.\n    else if (type == 'reset') {\n        this._reset();\n      }\n  }\n  /** Called when the first child is added. */\n  ;\n\n  _proto._attach = function _attach() {}\n  /** Called when the last child is removed. */\n  ;\n\n  _proto._detach = function _detach() {}\n  /**\n   * Reset our animation state (eg: start values, velocity, etc)\n   * and tell our children to do the same.\n   *\n   * This is called when our goal value is changed during (or before)\n   * an animation.\n   */\n  ;\n\n  _proto._reset = function _reset() {\n    this._emit({\n      type: 'reset',\n      parent: this\n    });\n  }\n  /**\n   * Start animating if possible.\n   *\n   * Note: Be sure to call `_reset` first, or the animation will break.\n   * This method would like to call `_reset` for you, but that would\n   * interfere with paused animations.\n   */\n  ;\n\n  _proto._start = function _start() {\n    this._emit({\n      type: 'start',\n      parent: this\n    });\n  }\n  /** Tell our children about our new value */\n  ;\n\n  _proto._onChange = function _onChange(value, idle) {\n    if (idle === void 0) {\n      idle = false;\n    }\n\n    this._emit({\n      type: 'change',\n      parent: this,\n      value: value,\n      idle: idle\n    });\n  }\n  /** Tell our children about our new priority */\n  ;\n\n  _proto._onPriorityChange = function _onPriorityChange(priority) {\n    if (!this.idle) {\n      // Make the frameloop aware of our new priority.\n      G.frameLoop.start(this);\n    }\n\n    this._emit({\n      type: 'priority',\n      parent: this,\n      priority: priority\n    });\n  };\n\n  _proto._emit = function _emit(event) {\n    // Clone \"_children\" so it can be safely mutated inside the loop.\n    shared.each(Array.from(this._children), function (child) {\n      child.onParentChange(event);\n    });\n  };\n\n  _createClass(FrameValue, [{\n    key: \"priority\",\n    get: function get() {\n      return this._priority;\n    },\n    set: function set(priority) {\n      if (this._priority != priority) {\n        this._priority = priority;\n\n        this._onPriorityChange(priority);\n      }\n    }\n  }]);\n\n  return FrameValue;\n}(shared.FluidValue);\n\n// TODO: use \"const enum\" when Babel supports it\n\n/** The spring has not animated yet */\nvar CREATED = 'CREATED';\n/** The spring has animated before */\n\nvar IDLE = 'IDLE';\n/** The spring is animating */\n\nvar ACTIVE = 'ACTIVE';\n/** The spring is frozen in time */\n\nvar PAUSED = 'PAUSED';\n/** The spring cannot be animated */\n\nvar DISPOSED = 'DISPOSED';\n\n/**\n * Only numbers, strings, and arrays of numbers/strings are supported.\n * Non-animatable strings are also supported.\n */\nvar SpringValue = /*#__PURE__*/function (_FrameValue) {\n  _inheritsLoose(SpringValue, _FrameValue);\n\n  function SpringValue(arg1, arg2) {\n    var _this;\n\n    _this = _FrameValue.call(this) || this;\n    _this.key = void 0;\n    _this.animation = new Animation();\n    _this.queue = void 0;\n    _this._phase = CREATED;\n    _this._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    _this._defaultProps = {};\n    _this._lastCallId = 0;\n    _this._lastToId = 0;\n\n    if (!shared.is.und(arg1) || !shared.is.und(arg2)) {\n      var _props = shared.is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n        from: arg1\n      });\n\n      _props[\"default\"] = true;\n\n      _this.start(_props);\n    }\n\n    return _this;\n  }\n\n  var _proto = SpringValue.prototype;\n\n  /** Advance the current animation by a number of milliseconds */\n  _proto.advance = function advance(dt) {\n    var _this2 = this;\n\n    var idle = true;\n    var changed = false;\n    var anim = this.animation;\n    var config = anim.config,\n        toValues = anim.toValues;\n    var payload = animated.getPayload(anim.to);\n\n    if (!payload) {\n      var toConfig = shared.getFluidConfig(anim.to);\n\n      if (toConfig) {\n        toValues = shared.toArray(toConfig.get());\n      }\n    }\n\n    anim.values.forEach(function (node, i) {\n      if (node.done) return; // The \"anim.toValues\" array must exist when no parent exists.\n\n      var to = payload ? payload[i].lastPosition : toValues[i];\n      var finished = anim.immediate;\n      var position = to;\n\n      if (!finished) {\n        position = node.lastPosition; // Loose springs never move.\n\n        if (config.tension <= 0) {\n          node.done = true;\n          return;\n        }\n\n        var elapsed = node.elapsedTime += dt;\n        var _from = anim.fromValues[i];\n        var v0 = node.v0 != null ? node.v0 : node.v0 = shared.is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n        var velocity; // Duration easing\n\n        if (!shared.is.und(config.duration)) {\n          var p = config.progress || 0;\n          if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);\n          position = _from + config.easing(p) * (to - _from);\n          velocity = (position - node.lastPosition) / dt;\n          finished = p == 1;\n        } // Decay easing\n        else if (config.decay) {\n            var decay = config.decay === true ? 0.998 : config.decay;\n            var e = Math.exp(-(1 - decay) * elapsed);\n            position = _from + v0 / (1 - decay) * (1 - e);\n            finished = Math.abs(node.lastPosition - position) < 0.1; // derivative of position\n\n            velocity = v0 * e;\n          } // Spring easing\n          else {\n              velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n              /** The smallest distance from a value before being treated like said value. */\n\n              var precision = config.precision || (_from == to ? 0.005 : Math.min(1, Math.abs(to - _from) * 0.001));\n              /** The velocity at which movement is essentially none */\n\n              var restVelocity = config.restVelocity || precision / 10; // Bouncing is opt-in (not to be confused with overshooting)\n\n              var bounceFactor = config.clamp ? 0 : config.bounce;\n              var canBounce = !shared.is.und(bounceFactor);\n              /** When `true`, the value is increasing over time */\n\n              var isGrowing = _from == to ? node.v0 > 0 : _from < to;\n              /** When `true`, the velocity is considered moving */\n\n              var isMoving;\n              /** When `true`, the velocity is being deflected or clamped */\n\n              var isBouncing = false;\n              var step = 1; // 1ms\n\n              var numSteps = Math.ceil(dt / step);\n\n              for (var n = 0; n < numSteps; ++n) {\n                isMoving = Math.abs(velocity) > restVelocity;\n\n                if (!isMoving) {\n                  finished = Math.abs(to - position) <= precision;\n\n                  if (finished) {\n                    break;\n                  }\n                }\n\n                if (canBounce) {\n                  isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.\n\n                  if (isBouncing) {\n                    velocity = -velocity * bounceFactor;\n                    position = to;\n                  }\n                }\n\n                var springForce = -config.tension * 0.000001 * (position - to);\n                var dampingForce = -config.friction * 0.001 * velocity;\n                var acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2\n\n                velocity = velocity + acceleration * step; // pt/ms\n\n                position = position + velocity * step;\n              }\n            }\n\n        node.lastVelocity = velocity;\n\n        if (Number.isNaN(position)) {\n          console.warn(\"Got NaN while animating:\", _this2);\n          finished = true;\n        }\n      } // Parent springs must finish before their children can.\n\n\n      if (payload && !payload[i].done) {\n        finished = false;\n      }\n\n      if (finished) {\n        node.done = true;\n      } else {\n        idle = false;\n      }\n\n      if (node.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n\n    if (idle) {\n      this.finish();\n    } else if (changed) {\n      this._onChange(this.get());\n    }\n\n    return idle;\n  }\n  /** Check the current phase */\n  ;\n\n  _proto.is = function is(phase) {\n    return this._phase == phase;\n  }\n  /** Set the current value, while stopping the current animation */\n  ;\n\n  _proto.set = function set(value) {\n    var _this3 = this;\n\n    G.batchedUpdates(function () {\n      _this3._focus(value);\n\n      if (_this3._set(value)) {\n        // Ensure change observers are notified. When active,\n        // the \"_stop\" method handles this.\n        if (!_this3.is(ACTIVE)) {\n          return _this3._onChange(_this3.get(), true);\n        }\n      }\n\n      _this3._stop();\n    });\n    return this;\n  }\n  /**\n   * Freeze the active animation in time.\n   * This does nothing when not animating.\n   */\n  ;\n\n  _proto.pause = function pause() {\n    checkDisposed(this, 'pause');\n\n    if (!this.is(PAUSED)) {\n      this._phase = PAUSED;\n      shared.flush(this._state.pauseQueue, function (onPause) {\n        return onPause();\n      });\n    }\n  }\n  /** Resume the animation if paused. */\n  ;\n\n  _proto.resume = function resume() {\n    checkDisposed(this, 'resume');\n\n    if (this.is(PAUSED)) {\n      this._start();\n\n      shared.flush(this._state.resumeQueue, function (onResume) {\n        return onResume();\n      });\n    }\n  }\n  /**\n   * Skip to the end of the current animation.\n   *\n   * All `onRest` callbacks are passed `{finished: true}`\n   */\n  ;\n\n  _proto.finish = function finish(to) {\n    var _this4 = this;\n\n    this.resume();\n\n    if (this.is(ACTIVE)) {\n      var anim = this.animation; // Decay animations have an implicit goal.\n\n      if (!anim.config.decay && shared.is.und(to)) {\n        to = anim.to;\n      } // Set the value if we can.\n\n\n      if (!shared.is.und(to)) {\n        this._set(to);\n      }\n\n      G.batchedUpdates(function () {\n        // Ensure the \"onStart\" and \"onRest\" props are called.\n        if (!anim.changed) {\n          anim.changed = true;\n\n          if (anim.onStart) {\n            anim.onStart(_this4);\n          }\n        } // Exit the frameloop.\n\n\n        _this4._stop();\n      });\n    }\n\n    return this;\n  }\n  /** Push props into the pending queue. */\n  ;\n\n  _proto.update = function update(props) {\n    checkDisposed(this, 'update');\n    var queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n  /**\n   * Update this value's animation using the queue of pending props,\n   * and unpause the current animation (if one is frozen).\n   *\n   * When arguments are passed, a new animation is created, and the\n   * queued animations are left alone.\n   */\n  ;\n\n  _proto.start = /*#__PURE__*/function () {\n    var _start2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(to, arg2) {\n      var _this5 = this;\n\n      var queue, results;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              checkDisposed(this, 'start');\n\n              if (!shared.is.und(to)) {\n                queue = [shared.is.obj(to) ? to : _extends(_extends({}, arg2), {}, {\n                  to: to\n                })];\n              } else {\n                queue = this.queue || [];\n                this.queue = [];\n              }\n\n              _context.next = 4;\n              return Promise.all(queue.map(function (props) {\n                return _this5._update(props);\n              }));\n\n            case 4:\n              results = _context.sent;\n              return _context.abrupt(\"return\", getCombinedResult(this, results));\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function start(_x, _x2) {\n      return _start2.apply(this, arguments);\n    }\n\n    return start;\n  }()\n  /**\n   * Stop the current animation, and cancel any delayed updates.\n   *\n   * Pass `true` to call `onRest` with `cancelled: true`.\n   */\n  ;\n\n  _proto.stop = function stop(cancel) {\n    var _this6 = this;\n\n    if (!this.is(DISPOSED)) {\n      cancelAsync(this._state, this._lastCallId); // Ensure the `to` value equals the current value.\n\n      this._focus(this.get()); // Exit the frameloop and notify `onRest` listeners.\n\n\n      G.batchedUpdates(function () {\n        return _this6._stop(cancel);\n      });\n    }\n\n    return this;\n  }\n  /** Restart the animation. */\n  ;\n\n  _proto.reset = function reset() {\n    this._update({\n      reset: true\n    });\n  }\n  /** Prevent future animations, and stop the current animation */\n  ;\n\n  _proto.dispose = function dispose() {\n    if (!this.is(DISPOSED)) {\n      if (this.animation) {\n        // Prevent \"onRest\" calls when disposed.\n        this.animation.onRest = [];\n      }\n\n      this.stop();\n      this._phase = DISPOSED;\n    }\n  }\n  /** @internal */\n  ;\n\n  _proto.onParentChange = function onParentChange(event) {\n    _FrameValue.prototype.onParentChange.call(this, event);\n\n    if (event.type == 'change') {\n      if (!this.is(ACTIVE)) {\n        this._reset();\n\n        if (!this.is(PAUSED)) {\n          this._start();\n        }\n      }\n    } else if (event.type == 'priority') {\n      this.priority = event.priority + 1;\n    }\n  }\n  /**\n   * Parse the `to` and `from` range from the given `props` object.\n   *\n   * This also ensures the initial value is available to animated components\n   * during the render phase.\n   */\n  ;\n\n  _proto._prepareNode = function _prepareNode(_ref) {\n    var to = _ref.to,\n        from = _ref.from,\n        reverse = _ref.reverse;\n    var key = this.key || '';\n    to = !shared.is.obj(to) || shared.getFluidConfig(to) ? to : to[key];\n    from = !shared.is.obj(from) || shared.getFluidConfig(from) ? from : from[key]; // Create the range now to avoid \"reverse\" logic.\n\n    var range = {\n      to: to,\n      from: from\n    }; // Before ever animating, this method ensures an `Animated` node\n    // exists and keeps its value in sync with the \"from\" prop.\n\n    if (this.is(CREATED)) {\n      if (reverse) {\n        var _ref2 = [from, to];\n        to = _ref2[0];\n        from = _ref2[1];\n      }\n\n      from = shared.getFluidValue(from);\n\n      var node = this._updateNode(shared.is.und(from) ? shared.getFluidValue(to) : from);\n\n      if (node && !shared.is.und(from)) {\n        node.setValue(from);\n      }\n    }\n\n    return range;\n  }\n  /**\n   * Create an `Animated` node if none exists or the given value has an\n   * incompatible type. Do nothing if `value` is undefined.\n   *\n   * The newest `Animated` node is returned.\n   */\n  ;\n\n  _proto._updateNode = function _updateNode(value) {\n    var node = animated.getAnimated(this);\n\n    if (!shared.is.und(value)) {\n      var nodeType = this._getNodeType(value);\n\n      if (!node || node.constructor !== nodeType) {\n        animated.setAnimated(this, node = nodeType.create(value));\n      }\n    }\n\n    return node;\n  }\n  /** Return the `Animated` node constructor for a given value */\n  ;\n\n  _proto._getNodeType = function _getNodeType(value) {\n    var parentNode = animated.getAnimated(value);\n    return parentNode ? parentNode.constructor : shared.is.arr(value) ? animated.AnimatedArray : shared.isAnimatedString(value) ? animated.AnimatedString : animated.AnimatedValue;\n  }\n  /** Schedule an animation to run after an optional delay */\n  ;\n\n  _proto._update = function _update(props, isLoop) {\n    var _this7 = this;\n\n    var defaultProps = this._defaultProps;\n\n    var mergeDefaultProp = function mergeDefaultProp(key) {\n      var value = getDefaultProp(props, key);\n\n      if (!shared.is.und(value)) {\n        defaultProps[key] = value;\n      } // For `cancel` and `pause`, a truthy default always wins.\n\n\n      if (defaultProps[key]) {\n        props[key] = defaultProps[key];\n      }\n    }; // These props are coerced into booleans by the `scheduleProps` function,\n    // so they need their default values processed before then.\n\n\n    mergeDefaultProp('cancel');\n    mergeDefaultProp('pause'); // Ensure the initial value can be accessed by animated components.\n\n    var range = this._prepareNode(props);\n\n    return scheduleProps(++this._lastCallId, {\n      key: this.key,\n      props: props,\n      state: this._state,\n      actions: {\n        pause: this.pause.bind(this),\n        resume: this.resume.bind(this),\n        start: this._merge.bind(this, range)\n      }\n    }).then(function (result) {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        var nextProps = createLoopUpdate(props);\n\n        if (nextProps) {\n          return _this7._update(nextProps, true);\n        }\n      }\n\n      return result;\n    });\n  }\n  /** Merge props into the current animation */\n  ;\n\n  _proto._merge = function _merge(range, props, resolve) {\n    // The \"cancel\" prop cancels all pending delays and it forces the\n    // active animation to stop where it is.\n    if (props.cancel) {\n      this.stop(true);\n      return resolve(getCancelledResult(this));\n    }\n\n    var key = this.key,\n        anim = this.animation;\n    var defaultProps = this._defaultProps;\n    /** The \"to\" prop is defined. */\n\n    var hasToProp = !shared.is.und(range.to);\n    /** The \"from\" prop is defined. */\n\n    var hasFromProp = !shared.is.und(range.from); // Avoid merging other props if implicitly prevented, except\n    // when both the \"to\" and \"from\" props are undefined.\n\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId;\n      } else {\n        return resolve(getCancelledResult(this));\n      }\n    }\n    /** Get the value of a prop, or its default value */\n\n\n    var get = function get(prop) {\n      return !shared.is.und(props[prop]) ? props[prop] : defaultProps[prop];\n    }; // Call \"onDelayEnd\" before merging props, but after cancellation checks.\n\n\n    var onDelayEnd = coerceEventProp(get('onDelayEnd'), key);\n\n    if (onDelayEnd) {\n      onDelayEnd(props, this);\n    }\n\n    if (props[\"default\"]) {\n      mergeDefaultProps(defaultProps, props, ['pause', 'cancel']);\n    }\n\n    var prevTo = anim.to,\n        prevFrom = anim.from;\n    var _range$to = range.to,\n        to = _range$to === void 0 ? prevTo : _range$to,\n        _range$from = range.from,\n        from = _range$from === void 0 ? prevFrom : _range$from; // Focus the \"from\" value if changing without a \"to\" value.\n\n    if (hasFromProp && !hasToProp) {\n      to = from;\n    } // Flip the current range if \"reverse\" is true.\n\n\n    if (props.reverse) {\n      var _ref3 = [from, to];\n      to = _ref3[0];\n      from = _ref3[1];\n    }\n    /** The \"from\" value is changing. */\n\n\n    var hasFromChanged = !shared.isEqual(from, prevFrom);\n\n    if (hasFromChanged) {\n      anim.from = from;\n    }\n    /** The \"to\" value is changing. */\n\n\n    var hasToChanged = !shared.isEqual(to, prevTo);\n\n    if (hasToChanged) {\n      this._focus(to);\n    } // Both \"from\" and \"to\" can use a fluid config (thanks to http://npmjs.org/fluids).\n\n\n    var toConfig = shared.getFluidConfig(to);\n    var fromConfig = shared.getFluidConfig(from);\n\n    if (fromConfig) {\n      from = fromConfig.get();\n    }\n    /** The \"to\" prop is async. */\n\n\n    var hasAsyncTo = shared.is.arr(props.to) || shared.is.fun(props.to);\n    var config = anim.config;\n    var decay = config.decay,\n        velocity = config.velocity; // The \"runAsync\" function treats the \"config\" prop as a default,\n    // so we must avoid merging it when the \"to\" prop is async.\n\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(config, callProp(props.config, key), // Avoid calling the same \"config\" prop twice.\n      props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\n    } // This instance might not have its Animated node yet. For example,\n    // the constructor can be given props without a \"to\" or \"from\" value.\n\n\n    var node = animated.getAnimated(this);\n\n    if (!node || shared.is.und(to)) {\n      return resolve(getFinishedResult(this, true));\n    }\n    /** When true, start at the \"from\" value. */\n\n\n    var reset = // When `reset` is undefined, the `from` prop implies `reset: true`,\n    // except for declarative updates. When `reset` is defined, there\n    // must exist a value to animate from.\n    shared.is.und(props.reset) ? hasFromProp && !props[\"default\"] : !shared.is.und(from) && matchProp(props.reset, key); // The current value, where the animation starts from.\n\n    var value = reset ? from : this.get(); // The animation ends at this value, unless \"to\" is fluid.\n\n    var goal = computeGoal(to); // Only specific types can be animated to/from.\n\n    var isAnimatable = shared.is.num(goal) || shared.is.arr(goal) || shared.isAnimatedString(goal); // When true, the value changes instantly on the next frame.\n\n    var immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n\n    if (hasToChanged) {\n      if (immediate) {\n        node = this._updateNode(goal);\n      } else {\n        var nodeType = this._getNodeType(to);\n\n        if (nodeType !== node.constructor) {\n          throw Error(\"Cannot animate between \" + node.constructor.name + \" and \" + nodeType.name + \", as the \\\"to\\\" prop suggests\");\n        }\n      }\n    } // The type of Animated node for the goal value.\n\n\n    var goalType = node.constructor; // When the goal value is fluid, we don't know if its value\n    // will change before the next animation frame, so it always\n    // starts the animation to be safe.\n\n    var started = !!toConfig;\n    var finished = false;\n\n    if (!started) {\n      // When true, the current value has probably changed.\n      var hasValueChanged = reset || this.is(CREATED) && hasFromChanged; // When the \"to\" value or current value are changed,\n      // start animating if not already finished.\n\n      if (hasToChanged || hasValueChanged) {\n        finished = shared.isEqual(computeGoal(value), goal);\n        started = !finished;\n      } // Changing \"decay\" or \"velocity\" starts the animation.\n\n\n      if (!shared.isEqual(config.decay, decay) || !shared.isEqual(config.velocity, velocity)) {\n        started = true;\n      }\n    } // When an active animation changes its goal to its current value:\n\n\n    if (finished && this.is(ACTIVE)) {\n      // Avoid an abrupt stop unless the animation is being reset.\n      if (anim.changed && !reset) {\n        started = true;\n      } // Stop the animation before its first frame.\n      else if (!started) {\n          this._stop();\n        }\n    }\n\n    if (!hasAsyncTo) {\n      // Make sure our \"toValues\" are updated even if our previous\n      // \"to\" prop is a fluid value whose current value is also ours.\n      if (started || shared.getFluidConfig(prevTo)) {\n        anim.values = node.getPayload();\n        anim.toValues = toConfig ? null : goalType == animated.AnimatedString ? [1] : shared.toArray(goal);\n      }\n\n      anim.immediate = immediate;\n      anim.onStart = coerceEventProp(get('onStart'), key);\n      anim.onChange = coerceEventProp(get('onChange'), key); // The \"reset\" prop tries to reuse the old \"onRest\" prop,\n      // unless you defined a new \"onRest\" prop.\n\n      var onRestQueue = anim.onRest;\n      var onRest = reset && !props.onRest ? onRestQueue[0] || shared.noop : checkFinishedOnRest(coerceEventProp(get('onRest'), key), this); // In most cases, the animation after this one won't reuse our\n      // \"onRest\" prop. Instead, the _default_ \"onRest\" prop is used\n      // when the next animation has an undefined \"onRest\" prop.\n\n      if (started) {\n        anim.onRest = [onRest, checkFinishedOnRest(resolve, this)]; // Flush the \"onRest\" queue for the previous animation.\n\n        var onRestIndex = reset ? 0 : 1;\n\n        if (onRestIndex < onRestQueue.length) {\n          G.batchedUpdates(function () {\n            for (; onRestIndex < onRestQueue.length; onRestIndex++) {\n              onRestQueue[onRestIndex]();\n            }\n          });\n        }\n      } // The \"onRest\" prop is always first, and it can be updated even\n      // if a new animation is not started by this update.\n      else if (reset || props.onRest) {\n          anim.onRest[0] = onRest;\n        }\n    } // By this point, every prop has been merged.\n\n\n    var onProps = coerceEventProp(get('onProps'), key);\n\n    if (onProps) {\n      onProps(props, this);\n    } // Update our node even if the animation is idle.\n\n\n    if (reset) {\n      node.setValue(value);\n    }\n\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this));\n    } // Start an animation\n    else if (started) {\n        // Must be idle for \"onStart\" to be called again.\n        if (reset) this._phase = IDLE;\n\n        this._reset();\n\n        this._start();\n      } // Postpone promise resolution until the animation is finished,\n      // so that no-op updates still resolve at the expected time.\n      else if (this.is(ACTIVE) && !hasToChanged) {\n          anim.onRest.push(checkFinishedOnRest(resolve, this));\n        } // Resolve our promise immediately.\n        else {\n            resolve(getNoopResult(this, value));\n          }\n  }\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n  ;\n\n  _proto._focus = function _focus(value) {\n    var anim = this.animation;\n\n    if (value !== anim.to) {\n      var config = shared.getFluidConfig(anim.to);\n\n      if (config) {\n        config.removeChild(this);\n      }\n\n      anim.to = value;\n      var priority = 0;\n\n      if (config = shared.getFluidConfig(value)) {\n        config.addChild(this);\n\n        if (isFrameValue(value)) {\n          priority = (value.priority || 0) + 1;\n        }\n      }\n\n      this.priority = priority;\n    }\n  }\n  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */\n  ;\n\n  _proto._set = function _set(value) {\n    var config = shared.getFluidConfig(value);\n\n    if (config) {\n      value = config.get();\n    }\n\n    var node = animated.getAnimated(this);\n    var oldValue = node && node.getValue();\n\n    if (node) {\n      node.setValue(value);\n    } else {\n      this._updateNode(value);\n    }\n\n    return !shared.isEqual(value, oldValue);\n  };\n\n  _proto._onChange = function _onChange(value, idle) {\n    if (idle === void 0) {\n      idle = false;\n    }\n\n    var anim = this.animation; // The \"onStart\" prop is called on the first change after entering the\n    // frameloop, but never for immediate animations.\n\n    if (!anim.changed && !idle) {\n      anim.changed = true;\n\n      if (anim.onStart) {\n        anim.onStart(this);\n      }\n    }\n\n    if (anim.onChange) {\n      anim.onChange(value, this);\n    }\n\n    _FrameValue.prototype._onChange.call(this, value, idle);\n  };\n\n  _proto._reset = function _reset() {\n    var anim = this.animation; // Reset the state of each Animated node.\n\n    animated.getAnimated(this).reset(anim.to); // Ensure the `onStart` prop will be called.\n\n    if (!this.is(ACTIVE)) {\n      anim.changed = false;\n    } // Use the current values as the from values.\n\n\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(function (node) {\n        return node.lastPosition;\n      });\n    }\n\n    _FrameValue.prototype._reset.call(this);\n  };\n\n  _proto._start = function _start() {\n    if (!this.is(ACTIVE)) {\n      this._phase = ACTIVE;\n\n      _FrameValue.prototype._start.call(this); // The \"skipAnimation\" global avoids the frameloop.\n\n\n      if (G.skipAnimation) {\n        this.finish();\n      } else {\n        G.frameLoop.start(this);\n      }\n    }\n  }\n  /**\n   * Exit the frameloop and notify `onRest` listeners.\n   *\n   * Always wrap `_stop` calls with `batchedUpdates`.\n   */\n  ;\n\n  _proto._stop = function _stop(cancel) {\n    this.resume();\n\n    if (this.is(ACTIVE)) {\n      this._phase = IDLE; // Always let change observers know when a spring becomes idle.\n\n      this._onChange(this.get(), true);\n\n      var anim = this.animation;\n      shared.each(anim.values, function (node) {\n        node.done = true;\n      });\n      var onRestQueue = anim.onRest;\n\n      if (onRestQueue.length) {\n        // Preserve the \"onRest\" prop when the goal is dynamic.\n        anim.onRest = [anim.toValues ? shared.noop : onRestQueue[0]]; // Never call the \"onRest\" prop for no-op animations.\n\n        if (!anim.changed) {\n          onRestQueue[0] = shared.noop;\n        }\n\n        shared.each(onRestQueue, function (onRest) {\n          return onRest(cancel);\n        });\n      }\n    }\n  };\n\n  _createClass(SpringValue, [{\n    key: \"idle\",\n    get: function get() {\n      return !this.is(ACTIVE) && !this._state.asyncTo;\n    }\n  }, {\n    key: \"goal\",\n    get: function get() {\n      return shared.getFluidValue(this.animation.to);\n    }\n  }, {\n    key: \"velocity\",\n    get: function get() {\n      var node = animated.getAnimated(this);\n      return node instanceof animated.AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(function (node) {\n        return node.lastVelocity || 0;\n      });\n    }\n  }]);\n\n  return SpringValue;\n}(FrameValue);\n\nfunction checkDisposed(spring, name) {\n  if (spring.is(DISPOSED)) {\n    throw Error(\"Cannot call \\\"\" + name + \"\\\" of disposed \\\"\" + spring.constructor.name + \"\\\" object\");\n  }\n}\n/** Coerce an event prop to an event handler */\n\n\nfunction coerceEventProp(prop, key) {\n  return shared.is.fun(prop) ? prop : key && prop ? prop[key] : undefined;\n}\n/**\n * The \"finished\" value is determined by each \"onRest\" handler,\n * based on whether the current value equals the goal value that\n * was calculated at the time the \"onRest\" handler was set.\n */\n\n\nvar checkFinishedOnRest = function checkFinishedOnRest(onRest, spring) {\n  var to = spring.animation.to;\n  return onRest ? function (cancel) {\n    if (cancel) {\n      onRest(getCancelledResult(spring));\n    } else {\n      var goal = computeGoal(to);\n      var value = computeGoal(spring.get());\n      var finished = shared.isEqual(value, goal);\n      onRest(getFinishedResult(spring, finished));\n    }\n  } : shared.noop;\n};\n\nfunction createLoopUpdate(props, loop, to) {\n  if (loop === void 0) {\n    loop = props.loop;\n  }\n\n  if (to === void 0) {\n    to = props.to;\n  }\n\n  var loopRet = callProp(loop);\n\n  if (loopRet) {\n    var overrides = loopRet !== true && inferTo(loopRet);\n    var reverse = (overrides || props).reverse;\n    var reset = !overrides || overrides.reset;\n    return createUpdate(_extends(_extends({}, props), {}, {\n      loop: loop,\n      // Avoid updating default props when looping.\n      \"default\": false,\n      // For the \"reverse\" prop to loop as expected, the \"to\" prop\n      // must be undefined. The \"reverse\" prop is ignored when the\n      // \"to\" prop is an array or function.\n      to: !reverse || shared.is.arr(to) || shared.is.fun(to) ? to : undefined,\n      // Avoid defining the \"from\" prop if a reset is unwanted.\n      from: reset ? props.from : undefined,\n      reset: reset\n    }, overrides));\n  }\n}\n/**\n * Return a new object based on the given `props`.\n *\n * - All unreserved props are moved into the `to` prop object.\n * - The `to` and `from` props are deleted when falsy.\n * - The `keys` prop is set to an array of affected keys,\n *   or `null` if all keys are affected.\n */\n\nfunction createUpdate(props) {\n  var _props2 = props = inferTo(props),\n      to = _props2.to,\n      from = _props2.from; // Collect the keys affected by this update.\n\n\n  var keys = new Set();\n\n  if (from) {\n    findDefined(from, keys);\n  } else {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.from;\n  }\n\n  if (shared.is.obj(to)) {\n    findDefined(to, keys);\n  } else if (!to) {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.to;\n  } // The \"keys\" prop helps in applying updates to affected keys only.\n\n\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\n/**\n * A modified version of `createUpdate` meant for declarative APIs.\n */\n\nfunction declareUpdate(props) {\n  var update = createUpdate(props);\n\n  if (shared.is.und(update[\"default\"])) {\n    update[\"default\"] = getDefaultProps(update, [// Avoid forcing `immediate: true` onto imperative updates.\n    update.immediate === true && 'immediate']);\n  }\n\n  return update;\n}\n/** Find keys with defined values */\n\nfunction findDefined(values, keys) {\n  shared.each(values, function (value, key) {\n    return value != null && keys.add(key);\n  });\n}\n\n/** Events batched by the `Controller` class */\nvar BATCHED_EVENTS = ['onStart', 'onChange', 'onRest'];\nvar nextId$1 = 1;\n/** Queue of pending updates for a `Controller` instance. */\n\nvar Controller = /*#__PURE__*/function () {\n  /** The animated values */\n\n  /** The queue of props passed to the `update` method. */\n\n  /** Custom handler for flushing update queues */\n\n  /** These props are used by all future spring values */\n\n  /** The combined phase of our spring values */\n\n  /** The counter for tracking `scheduleProps` calls */\n\n  /** The values currently being animated */\n\n  /** State used by the `runAsync` function */\n\n  /** The event queues that are flushed once per frame maximum */\n  function Controller(props, flush) {\n    this.id = nextId$1++;\n    this.springs = {};\n    this.queue = [];\n    this._flush = void 0;\n    this._initialProps = void 0;\n    this._phase = CREATED;\n    this._lastAsyncId = 0;\n    this._active = new Set();\n    this._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    this._events = {\n      onStart: new Set(),\n      onChange: new Set(),\n      onRest: new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n\n    if (flush) {\n      this._flush = flush;\n    }\n\n    if (props) {\n      this.start(props);\n    }\n  }\n  /**\n   * Equals `true` when no spring values are in the frameloop, and\n   * no async animation is currently active.\n   */\n\n\n  var _proto = Controller.prototype;\n\n  /** Check the current phase */\n  _proto.is = function is(phase) {\n    return this._phase == phase;\n  }\n  /** Get the current values of our springs */\n  ;\n\n  _proto.get = function get() {\n    var values = {};\n    this.each(function (spring, key) {\n      return values[key] = spring.get();\n    });\n    return values;\n  }\n  /** Push an update onto the queue of each value. */\n  ;\n\n  _proto.update = function update(props) {\n    if (props) this.queue.push(createUpdate(props));\n    return this;\n  }\n  /**\n   * Start the queued animations for every spring, and resolve the returned\n   * promise once all queued animations have finished or been cancelled.\n   *\n   * When you pass a queue (instead of nothing), that queue is used instead of\n   * the queued animations added with the `update` method, which are left alone.\n   */\n  ;\n\n  _proto.start = function start(props) {\n    var queue = props ? shared.toArray(props).map(createUpdate) : this.queue;\n\n    if (!props) {\n      this.queue = [];\n    }\n\n    if (this._flush) {\n      return this._flush(this, queue);\n    }\n\n    prepareKeys(this, queue);\n    return flushUpdateQueue(this, queue);\n  }\n  /** Stop one animation, some animations, or all animations */\n  ;\n\n  _proto.stop = function stop(keys) {\n    if (shared.is.und(keys)) {\n      this.each(function (spring) {\n        return spring.stop();\n      });\n      cancelAsync(this._state, this._lastAsyncId);\n    } else {\n      var springs = this.springs;\n\n      shared.each(shared.toArray(keys), function (key) {\n        return springs[key].stop();\n      });\n    }\n\n    return this;\n  }\n  /** Freeze the active animation in time */\n  ;\n\n  _proto.pause = function pause(keys) {\n    if (shared.is.und(keys)) {\n      this.each(function (spring) {\n        return spring.pause();\n      });\n    } else {\n      var springs = this.springs;\n\n      shared.each(shared.toArray(keys), function (key) {\n        return springs[key].pause();\n      });\n    }\n\n    return this;\n  }\n  /** Resume the animation if paused. */\n  ;\n\n  _proto.resume = function resume(keys) {\n    if (shared.is.und(keys)) {\n      this.each(function (spring) {\n        return spring.resume();\n      });\n    } else {\n      var springs = this.springs;\n\n      shared.each(shared.toArray(keys), function (key) {\n        return springs[key].resume();\n      });\n    }\n\n    return this;\n  }\n  /** Restart every animation. */\n  ;\n\n  _proto.reset = function reset() {\n    this.each(function (spring) {\n      return spring.reset();\n    }); // TODO: restart async \"to\" prop\n\n    return this;\n  }\n  /** Call a function once per spring value */\n  ;\n\n  _proto.each = function each(iterator) {\n    shared.each(this.springs, iterator);\n  }\n  /** Destroy every spring in this controller */\n  ;\n\n  _proto.dispose = function dispose() {\n    this._state.asyncTo = undefined;\n    this.each(function (spring) {\n      return spring.dispose();\n    });\n    this.springs = {};\n  }\n  /** @internal Called at the end of every animation frame */\n  ;\n\n  _proto._onFrame = function _onFrame() {\n    var _this = this;\n\n    var _this$_events = this._events,\n        onStart = _this$_events.onStart,\n        onChange = _this$_events.onChange,\n        onRest = _this$_events.onRest;\n    var isActive = this._active.size > 0;\n\n    if (isActive && this._phase != ACTIVE) {\n      this._phase = ACTIVE;\n      shared.flush(onStart, function (onStart) {\n        return onStart(_this);\n      });\n    }\n\n    var values = (onChange.size || !isActive && onRest.size) && this.get();\n    shared.flush(onChange, function (onChange) {\n      return onChange(values);\n    }); // The \"onRest\" queue is only flushed when all springs are idle.\n\n    if (!isActive) {\n      this._phase = IDLE;\n      shared.flush(onRest, function (_ref) {\n        var onRest = _ref[0],\n            result = _ref[1];\n        result.value = values;\n        onRest(result);\n      });\n    }\n  }\n  /** @internal */\n  ;\n\n  _proto.onParentChange = function onParentChange(event) {\n    if (event.type == 'change') {\n      this._active[event.idle ? 'delete' : 'add'](event.parent);\n\n      G.frameLoop.onFrame(this._onFrame);\n    }\n  };\n\n  _createClass(Controller, [{\n    key: \"idle\",\n    get: function get() {\n      return !this._state.asyncTo && Object.values(this.springs).every(function (spring) {\n        return spring.idle;\n      });\n    }\n  }]);\n\n  return Controller;\n}();\n/**\n * Warning: Props might be mutated.\n */\n\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map(function (props) {\n    return flushUpdate(ctrl, props);\n  })).then(function (results) {\n    return getCombinedResult(ctrl, results);\n  });\n}\n/**\n * Warning: Props might be mutated.\n *\n * Process a single set of props using the given controller.\n *\n * The returned promise resolves to `true` once the update is\n * applied and any animations it starts are finished without being\n * stopped or cancelled.\n */\n\nfunction flushUpdate(ctrl, props, isLoop) {\n  var to = props.to,\n      loop = props.loop,\n      onRest = props.onRest; // Looping must be handled in this function, or else the values\n  // would end up looping out-of-sync in many common cases.\n\n  if (loop) {\n    props.loop = false;\n  }\n\n  var asyncTo = shared.is.arr(to) || shared.is.fun(to) ? to : undefined;\n\n  if (asyncTo) {\n    props.to = undefined;\n    props.onRest = undefined;\n  } else {\n    // For certain events, use batching to prevent multiple calls per frame.\n    // However, batching is avoided when the `to` prop is async, because any\n    // event props are used as default props instead.\n    shared.each(BATCHED_EVENTS, function (key) {\n      var handler = props[key];\n\n      if (shared.is.fun(handler)) {\n        var queue = ctrl['_events'][key];\n\n        if (queue instanceof Set) {\n          props[key] = function () {\n            return queue.add(handler);\n          };\n        } else {\n          props[key] = function (_ref2) {\n            var finished = _ref2.finished,\n                cancelled = _ref2.cancelled;\n            var result = queue.get(handler);\n\n            if (result) {\n              if (!finished) result.finished = false;\n              if (cancelled) result.cancelled = true;\n            } else {\n              // The \"value\" is set before the \"handler\" is called.\n              queue.set(handler, {\n                value: null,\n                finished: finished,\n                cancelled: cancelled\n              });\n            }\n          };\n        }\n      }\n    });\n  }\n\n  var keys = props.keys || Object.keys(ctrl.springs);\n  var promises = keys.map(function (key) {\n    return ctrl.springs[key].start(props);\n  }); // Schedule the \"asyncTo\" if defined.\n\n  var state = ctrl['_state'];\n\n  if (asyncTo) {\n    promises.push(scheduleProps(++ctrl['_lastAsyncId'], {\n      props: props,\n      state: state,\n      actions: {\n        pause: shared.noop,\n        resume: shared.noop,\n        start: function start(props, resolve) {\n          props.onRest = onRest;\n\n          if (!props.cancel) {\n            resolve(runAsync(asyncTo, props, state, ctrl));\n          } // Prevent `cancel: true` from ending the current `runAsync` call,\n          // except when the default `cancel` prop is being set.\n          else if (hasDefaultProp(props, 'cancel')) {\n              cancelAsync(state, props.callId);\n            }\n        }\n      }\n    }));\n  } // Respect the `cancel` prop when no keys are affected.\n  else if (!props.keys && props.cancel === true) {\n      cancelAsync(state, ctrl['_lastAsyncId']);\n    }\n\n  return Promise.all(promises).then(function (results) {\n    var result = getCombinedResult(ctrl, results);\n\n    if (loop && result.finished && !(isLoop && result.noop)) {\n      var nextProps = createLoopUpdate(props, loop, to);\n\n      if (nextProps) {\n        prepareKeys(ctrl, [nextProps]);\n        return flushUpdate(ctrl, nextProps, true);\n      }\n    }\n\n    return result;\n  });\n}\n/**\n * From an array of updates, get the map of `SpringValue` objects\n * by their keys. Springs are created when any update wants to\n * animate a new key.\n *\n * Springs created by `getSprings` are neither cached nor observed\n * until they're given to `setSprings`.\n */\n\nfunction getSprings(ctrl, props) {\n  var springs = _extends({}, ctrl.springs);\n\n  if (props) {\n    shared.each(shared.toArray(props), function (props) {\n      if (shared.is.und(props.keys)) {\n        props = createUpdate(props);\n      }\n\n      if (!shared.is.obj(props.to)) {\n        // Avoid passing array/function to each spring.\n        props = _extends(_extends({}, props), {}, {\n          to: undefined\n        });\n      }\n\n      prepareSprings(springs, props, function (key) {\n        return createSpring(key);\n      });\n    });\n  }\n\n  return springs;\n}\n/**\n * Tell a controller to manage the given `SpringValue` objects\n * whose key is not already in use.\n */\n\nfunction setSprings(ctrl, springs) {\n  shared.each(springs, function (spring, key) {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      spring.addChild(ctrl);\n    }\n  });\n}\n\nfunction createSpring(key, observer) {\n  var spring = new SpringValue();\n  spring.key = key;\n\n  if (observer) {\n    spring.addChild(observer);\n  }\n\n  return spring;\n}\n/**\n * Ensure spring objects exist for each defined key.\n *\n * Using the `props`, the `Animated` node of each `SpringValue` may\n * be created or updated.\n */\n\n\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    shared.each(props.keys, function (key) {\n      var spring = springs[key] || (springs[key] = create(key));\n      spring['_prepareNode'](props);\n    });\n  }\n}\n/**\n * Ensure spring objects exist for each defined key, and attach the\n * `ctrl` to them for observation.\n *\n * The queue is expected to contain `createUpdate` results.\n */\n\n\nfunction prepareKeys(ctrl, queue) {\n  shared.each(queue, function (props) {\n    prepareSprings(ctrl.springs, props, function (key) {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n\n/**\n * This context affects all new and existing `SpringValue` objects\n * created with the hook API or the renderprops API.\n */\n\nvar ctx = React.createContext({});\nvar SpringContext = function SpringContext(_ref) {\n  var children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  var inherited = React.useContext(ctx); // Memoize the context to avoid unwanted renders.\n\n  props = useMemo(function () {\n    return _extends(_extends({}, inherited), props);\n  }, [inherited, props.pause, props.cancel, props.immediate, props.config]);\n  var Provider = ctx.Provider;\n  return /*#__PURE__*/React.createElement(Provider, {\n    value: props\n  }, children);\n};\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\n/** Get the current values of nearest `SpringContext` component. */\n\nvar useSpringContext = function useSpringContext() {\n  return React.useContext(ctx);\n};\n\n/** Create an imperative API for manipulating an array of `Controller` objects. */\nvar SpringHandle = {\n  create: function create(getControllers) {\n    return {\n      get controllers() {\n        return getControllers();\n      },\n\n      update: function update(props) {\n        shared.each(getControllers(), function (ctrl, i) {\n          ctrl.update(getProps(props, i, ctrl));\n        });\n        return this;\n      },\n      start: function start(props) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var results;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return Promise.all(getControllers().map(function (ctrl, i) {\n                    var update = getProps(props, i, ctrl);\n                    return ctrl.start(update);\n                  }));\n\n                case 2:\n                  results = _context.sent;\n                  return _context.abrupt(\"return\", {\n                    value: results.map(function (result) {\n                      return result.value;\n                    }),\n                    finished: results.every(function (result) {\n                      return result.finished;\n                    })\n                  });\n\n                case 4:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }))();\n      },\n      stop: function stop(keys) {\n        return shared.each(getControllers(), function (ctrl) {\n          return ctrl.stop(keys);\n        });\n      },\n      pause: function pause(keys) {\n        return shared.each(getControllers(), function (ctrl) {\n          return ctrl.pause(keys);\n        });\n      },\n      resume: function resume(keys) {\n        return shared.each(getControllers(), function (ctrl) {\n          return ctrl.resume(keys);\n        });\n      }\n    };\n  }\n};\n\n/** @internal */\nfunction useSprings(length, props, deps) {\n  var propsFn = shared.is.fun(props) && props;\n  if (propsFn && !deps) deps = [];\n  // Set to 0 to prevent sync flush.\n  var layoutId = React.useRef(0);\n  var forceUpdate = shared.useForceUpdate(); // State is updated on commit.\n\n  var _useState = React.useState(function () {\n    return {\n      ctrls: [],\n      queue: [],\n      flush: function flush(ctrl, updates) {\n        var springs = getSprings(ctrl, updates); // Flushing is postponed until the component's commit phase\n        // if a spring was created since the last commit.\n\n        var canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs).some(function (key) {\n          return !ctrl.springs[key];\n        });\n        return canFlushSync ? flushUpdateQueue(ctrl, updates) : new Promise(function (resolve) {\n          setSprings(ctrl, springs);\n          state.queue.push(function () {\n            resolve(flushUpdateQueue(ctrl, updates));\n          });\n          forceUpdate();\n        });\n      }\n    };\n  }),\n      state = _useState[0]; // The imperative API ref from the props of the first controller.\n\n\n  var refProp = React.useRef();\n  var ctrls = [].concat(state.ctrls);\n  var updates = []; // Cache old controllers to dispose in the commit phase.\n\n  var prevLength = shared.usePrev(length) || 0;\n  var disposed = ctrls.slice(length, prevLength); // Create new controllers when \"length\" increases, and destroy\n  // the affected controllers when \"length\" decreases.\n\n  useMemo(function () {\n    ctrls.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]); // Update existing controllers when \"deps\" are changed.\n\n  useMemo(function () {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n  /** Fill the `updates` array with declarative updates for the given index range. */\n\n  function declareUpdates(startIndex, endIndex) {\n    for (var _i = startIndex; _i < endIndex; _i++) {\n      var _ctrl = ctrls[_i] || (ctrls[_i] = new Controller(null, state.flush));\n\n      var update = propsFn ? propsFn(_i, _ctrl) : props[_i];\n\n      if (update) {\n        update = updates[_i] = declareUpdate(update);\n\n        if (_i == 0) {\n          refProp.current = update.ref;\n          update.ref = undefined;\n        }\n      }\n    }\n  }\n\n  var api = React.useMemo(function () {\n    return SpringHandle.create(function () {\n      return state.ctrls;\n    });\n  }, []); // New springs are created during render so users can pass them to\n  // their animated components, but new springs aren't cached until the\n  // commit phase (see the `useLayoutEffect` callback below).\n\n  var springs = ctrls.map(function (ctrl, i) {\n    return getSprings(ctrl, updates[i]);\n  });\n  var context = useSpringContext();\n  reactLayoutEffect.useLayoutEffect(function () {\n    layoutId.current++; // Replace the cached controllers.\n\n    state.ctrls = ctrls; // Update the ref prop.\n\n    if (refProp.current) {\n      refProp.current.current = api;\n    } // Flush the commit queue.\n\n\n    var queue = state.queue;\n\n    if (queue.length) {\n      state.queue = [];\n      shared.each(queue, function (cb) {\n        return cb();\n      });\n    } // Dispose unused controllers.\n\n\n    shared.each(disposed, function (ctrl) {\n      return ctrl.dispose();\n    }); // Update existing controllers.\n\n    shared.each(ctrls, function (ctrl, i) {\n      var values = springs[i];\n      setSprings(ctrl, values); // Update the default props.\n\n      ctrl.start({\n        \"default\": context\n      }); // Apply updates created during render.\n\n      var update = updates[i];\n\n      if (update) {\n        // Start animating unless a ref exists.\n        if (refProp.current) {\n          ctrl.queue.push(update);\n        } else {\n          ctrl.start(update);\n        }\n      }\n    });\n  }); // Dispose all controllers on unmount.\n\n  shared.useOnce(function () {\n    return function () {\n      shared.each(state.ctrls, function (ctrl) {\n        return ctrl.dispose();\n      });\n    };\n  }); // Return a deep copy of the `springs` array so the caller can\n  // safely mutate it during render.\n\n  var values = springs.map(function (x) {\n    return _extends({}, x);\n  });\n  return propsFn || arguments.length == 3 ? [values, api.start, api.stop] : values;\n}\n\n/**\n * The props that `useSpring` recognizes.\n */\n\n/** @internal */\nfunction useSpring(props, deps) {\n  var isFn = shared.is.fun(props);\n\n  var _useSprings = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps),\n      _useSprings$ = _useSprings[0],\n      values = _useSprings$[0],\n      update = _useSprings[1],\n      stop = _useSprings[2];\n\n  return isFn || arguments.length == 2 ? [values, update, stop] : values;\n}\n\nfunction useTrail(length, propsArg, deps) {\n  var propsFn = shared.is.fun(propsArg) && propsArg;\n  if (propsFn && !deps) deps = [];\n  var ctrls = [];\n  var result = useSprings(length, function (i, ctrl) {\n    ctrls[i] = ctrl;\n    return getProps(propsArg, i, ctrl);\n  }, // Ensure the props function is called when no deps exist.\n  // This works around the 3 argument rule.\n  deps || [{}]);\n  reactLayoutEffect.useLayoutEffect(function () {\n    var reverse = shared.is.obj(propsArg) && propsArg.reverse;\n\n    for (var _i = 0; _i < ctrls.length; _i++) {\n      var parent = ctrls[_i + (reverse ? 1 : -1)];\n      if (parent) ctrls[_i].update({\n        to: parent.springs\n      }).start();\n    }\n  }, deps);\n\n  if (propsFn || arguments.length == 3) {\n    var update = result[1];\n    result[1] = useMemoOne.useCallbackOne(function (propsArg) {\n      var reverse = shared.is.obj(propsArg) && propsArg.reverse;\n      return update(function (i, ctrl) {\n        var props = getProps(propsArg, i, ctrl);\n        var parent = ctrls[i + (reverse ? 1 : -1)];\n        if (parent) props.to = parent.springs;\n        return props;\n      });\n    }, deps);\n    return result;\n  }\n\n  return result[0];\n}\n\n// TODO: convert to \"const enum\" once Babel supports it\n\n/** This transition is being mounted */\nvar MOUNT = 'mount';\n/** This transition is entering or has entered */\n\nvar ENTER = 'enter';\n/** This transition had its animations updated */\n\nvar UPDATE = 'update';\n/** This transition will expire after animating */\n\nvar LEAVE = 'leave';\n\nfunction useTransition(data, props, deps) {\n  var ref = props.ref,\n      reset = props.reset,\n      sort = props.sort,\n      _props$trail = props.trail,\n      trail = _props$trail === void 0 ? 0 : _props$trail,\n      _props$expires = props.expires,\n      expires = _props$expires === void 0 ? true : _props$expires; // Every item has its own transition.\n\n  var items = shared.toArray(data);\n  var transitions = []; // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n\n  var keys = getKeys(items, props); // The \"onRest\" callbacks need a ref to the latest transitions.\n\n  var usedTransitions = React.useRef(null);\n  var prevTransitions = reset ? null : usedTransitions.current;\n  reactLayoutEffect.useLayoutEffect(function () {\n    usedTransitions.current = transitions;\n  }); // Destroy all transitions on dismount.\n\n  shared.useOnce(function () {\n    return function () {\n      return shared.each(usedTransitions.current, function (t) {\n        if (t.expired) {\n          clearTimeout(t.expirationId);\n        }\n\n        t.ctrl.dispose();\n      });\n    };\n  }); // Map old indices to new indices.\n\n  var reused = [];\n  if (prevTransitions) shared.each(prevTransitions, function (t, i) {\n    // Expired transitions are not rendered.\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  }); // Mount new items with fresh transitions.\n\n  shared.each(items, function (item, i) {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item: item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  }); // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n\n  if (reused.length) {\n    var i = -1;\n    shared.each(reused, function (keyIndex, prevIndex) {\n      var t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends(_extends({}, t), {}, {\n          item: items[keyIndex]\n        });\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (shared.is.fun(sort)) {\n    transitions.sort(function (a, b) {\n      return sort(a.item, b.item);\n    });\n  } // Track cumulative delay for the \"trail\" prop.\n\n\n  var delay = -trail; // Expired transitions use this to dismount.\n\n  var forceUpdate = shared.useForceUpdate(); // These props are inherited by every phase change.\n\n  var defaultProps = getDefaultProps(props); // Generate changes to apply in useEffect.\n\n  var changes = new Map();\n  shared.each(transitions, function (t, i) {\n    var key = t.key;\n    var prevPhase = t.phase;\n    var to;\n    var phase;\n\n    if (prevPhase == MOUNT) {\n      to = props.enter;\n      phase = ENTER;\n    } else {\n      var isLeave = keys.indexOf(key) < 0;\n\n      if (prevPhase != LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    } // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n    // (2) an async function, or (3) an object with any \"useSpring\" props.\n\n\n    to = callProp(to, t.item, i);\n    to = shared.is.obj(to) ? inferTo(to) : {\n      to: to\n    };\n\n    if (!to.config) {\n      var config = props.config || defaultProps.config;\n      to.config = callProp(config, t.item, i);\n    } // The payload is used to update the spring props once the current render is committed.\n\n\n    var payload = _extends(_extends({}, defaultProps), {}, {\n      delay: delay += trail,\n      // This prevents implied resets.\n      reset: false\n    }, to);\n\n    if (phase == ENTER && shared.is.und(payload.from)) {\n      // The `initial` prop is used on the first render of our parent component,\n      // as well as when `reset: true` is passed. It overrides the `from` prop\n      // when defined, and it makes `enter` instant when null.\n      var from = shared.is.und(props.initial) || prevTransitions ? props.from : props.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n\n    var onRest = payload.onRest;\n\n    payload.onRest = function (result) {\n      var transitions = usedTransitions.current;\n      var t = transitions.find(function (t) {\n        return t.key === key;\n      });\n      if (!t) return;\n\n      if (shared.is.fun(onRest)) {\n        onRest(result, t);\n      } // Reset the phase of a cancelled enter/leave transition, so it can\n      // retry the animation on the next render.\n\n\n      if (result.cancelled && t.phase != UPDATE) {\n        t.phase = prevPhase;\n        return;\n      }\n\n      if (t.ctrl.idle) {\n        var idle = transitions.every(function (t) {\n          return t.ctrl.idle;\n        });\n\n        if (t.phase == LEAVE) {\n          var expiry = callProp(expires, t.item);\n\n          if (expiry !== false) {\n            var expiryMs = expiry === true ? 0 : expiry;\n            t.expired = true; // Force update once the expiration delay ends.\n\n            if (!idle && expiryMs > 0) {\n              // The maximum timeout is 2^31-1\n              if (expiryMs <= 0x7fffffff) t.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        } // Force update once idle and expired items exist.\n\n\n        if (idle && transitions.some(function (t) {\n          return t.expired;\n        })) {\n          forceUpdate();\n        }\n      }\n    };\n\n    var springs = getSprings(t.ctrl, payload);\n    changes.set(t, {\n      phase: phase,\n      springs: springs,\n      payload: payload\n    });\n  }); // The prop overrides from an ancestor.\n\n  var context = useSpringContext(); // Merge the context into each transition.\n\n  reactLayoutEffect.useLayoutEffect(function () {\n    shared.each(transitions, function (t) {\n      t.ctrl.start({\n        \"default\": context\n      });\n    });\n  }, [context]);\n  var api = React.useMemo(function () {\n    return SpringHandle.create(function () {\n      return usedTransitions.current.map(function (t) {\n        return t.ctrl;\n      });\n    });\n  }, []);\n  React.useImperativeHandle(ref, function () {\n    return api;\n  });\n  reactLayoutEffect.useLayoutEffect(function () {\n    shared.each(changes, function (_ref, t) {\n      var phase = _ref.phase,\n          springs = _ref.springs,\n          payload = _ref.payload;\n      setSprings(t.ctrl, springs);\n\n      if (!context.cancel) {\n        t.phase = phase;\n\n        if (phase == ENTER) {\n          t.ctrl.start({\n            \"default\": context\n          });\n        }\n\n        t.ctrl[ref ? 'update' : 'start'](payload);\n      }\n    });\n  }, reset ? void 0 : deps);\n\n  var renderTransitions = function renderTransitions(render) {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, transitions.map(function (t, i) {\n      var _ref2 = changes.get(t) || t.ctrl,\n          springs = _ref2.springs;\n\n      var elem = render(_extends({}, springs), t.item, t, i);\n      return elem && elem.type ? /*#__PURE__*/React.createElement(elem.type, _extends({}, elem.props, {\n        key: shared.is.str(t.key) || shared.is.num(t.key) ? t.key : t.ctrl.id,\n        ref: elem.ref\n      })) : elem;\n    }));\n  };\n\n  return arguments.length == 3 ? [renderTransitions, api.start, api.stop] : renderTransitions;\n}\n\nfunction getKeys(items, _ref3) {\n  var key = _ref3.key,\n      _ref3$keys = _ref3.keys,\n      keys = _ref3$keys === void 0 ? key : _ref3$keys;\n  return shared.is.und(keys) ? items : shared.is.fun(keys) ? items.map(keys) : shared.toArray(keys);\n}\n\n/**\n * The `Spring` component passes `SpringValue` objects to your render prop.\n */\nfunction Spring(_ref) {\n  var children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return children(useSpring(props));\n}\n\nfunction Trail(_ref) {\n  var items = _ref.items,\n      children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n\n  var trails = useTrail(items.length, props);\n  return items.map(function (item, index) {\n    var result = children(item, index);\n    return shared.is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition(_ref) {\n  var items = _ref.items,\n      children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, useTransition(items, props)(children));\n}\n\n/**\n * An `Interpolation` is a memoized value that's computed whenever one of its\n * `FluidValue` dependencies has its value changed.\n *\n * Other `FrameValue` objects can depend on this. For example, passing an\n * `Interpolation` as the `to` prop of a `useSpring` call will trigger an\n * animation toward the memoized value.\n */\n\nvar Interpolation = /*#__PURE__*/function (_FrameValue) {\n  _inheritsLoose(Interpolation, _FrameValue);\n\n  /** Useful for debugging. */\n\n  /** Equals false when in the frameloop */\n\n  /** The function that maps inputs values to output */\n  function Interpolation(source, args) {\n    var _this;\n\n    _this = _FrameValue.call(this) || this;\n    _this.source = source;\n    _this.key = void 0;\n    _this.idle = true;\n    _this.calc = void 0;\n    _this.calc = shared.createInterpolator.apply(void 0, args);\n\n    var value = _this._get();\n\n    var nodeType = shared.is.arr(value) ? animated.AnimatedArray : animated.AnimatedValue; // Assume the computed value never changes type.\n\n    animated.setAnimated(_assertThisInitialized(_this), nodeType.create(value));\n    return _this;\n  }\n\n  var _proto = Interpolation.prototype;\n\n  _proto.advance = function advance(_dt) {\n    var value = this._get();\n\n    var oldValue = this.get();\n\n    if (!shared.isEqual(value, oldValue)) {\n      animated.getAnimated(this).setValue(value);\n\n      this._onChange(value, this.idle);\n    }\n  };\n\n  _proto._get = function _get() {\n    var inputs = shared.is.arr(this.source) ? this.source.map(function (node) {\n      return node.get();\n    }) : shared.toArray(this.source.get());\n    return this.calc.apply(this, inputs);\n  };\n\n  _proto._reset = function _reset() {\n    shared.each(animated.getPayload(this), function (node) {\n      return node.reset();\n    });\n\n    _FrameValue.prototype._reset.call(this);\n  };\n\n  _proto._start = function _start() {\n    this.idle = false;\n\n    _FrameValue.prototype._start.call(this);\n\n    if (G.skipAnimation) {\n      this.idle = true;\n      this.advance();\n    } else {\n      G.frameLoop.start(this);\n    }\n  };\n\n  _proto._attach = function _attach() {\n    var _this2 = this;\n\n    // Start observing our \"source\" once we have an observer.\n    var idle = true;\n    var priority = 1;\n    shared.each(shared.toArray(this.source), function (source) {\n      if (isFrameValue(source)) {\n        if (!source.idle) idle = false;\n        priority = Math.max(priority, source.priority + 1);\n      }\n\n      source.addChild(_this2);\n    });\n    this.priority = priority;\n\n    if (!idle) {\n      this._reset();\n\n      this._start();\n    }\n  };\n\n  _proto._detach = function _detach() {\n    var _this3 = this;\n\n    // Stop observing our \"source\" once we have no observers.\n    shared.each(shared.toArray(this.source), function (source) {\n      source.removeChild(_this3);\n    }); // This removes us from the frameloop.\n\n    this.idle = true;\n  }\n  /** @internal */\n  ;\n\n  _proto.onParentChange = function onParentChange(event) {\n    // Ensure our start value respects our parent values, in case\n    // any of their animations were restarted with the \"reset\" prop.\n    if (event.type == 'start') {\n      this.advance();\n    } // Change events are useful for (1) reacting to non-animated parents\n    // and (2) reacting to the last change in a parent animation.\n    else if (event.type == 'change') {\n        // If we're idle, we know for sure that this change is *not*\n        // caused by an animation.\n        if (this.idle) {\n          this.advance();\n        } // Leave the frameloop when all parents are done animating.\n        else if (event.idle) {\n            this.idle = shared.toArray(this.source).every(function (source) {\n              return source.idle !== false;\n            });\n\n            if (this.idle) {\n              this.advance();\n              shared.each(animated.getPayload(this), function (node) {\n                node.done = true;\n              });\n            }\n          }\n      } // Ensure our priority is greater than all parents, which means\n      // our value won't be updated until our parents have updated.\n      else if (event.type == 'priority') {\n          this.priority = shared.toArray(this.source).reduce(function (max, source) {\n            return Math.max(max, (source.priority || 0) + 1);\n          }, 0);\n        }\n\n    _FrameValue.prototype.onParentChange.call(this, event);\n  };\n\n  return Interpolation;\n}(FrameValue);\n\n/** Map the value of one or more dependencies */\n\nvar to = function to(source) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return new Interpolation(source, args);\n};\n/** @deprecated Use the `to` export instead */\n\nvar interpolate = function interpolate(source) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  return deprecations.deprecateInterpolate(), new Interpolation(source, args);\n};\n/** Extract the raw value types that are being interpolated */\n\nshared.Globals.assign({\n  createStringInterpolator: stringInterpolation.createStringInterpolator,\n  to: function to(source, args) {\n    return new Interpolation(source, args);\n  }\n});\n/** Advance all animations forward one frame */\n\nvar update = function update() {\n  return shared.Globals.frameLoop.advance();\n};\n\nObject.keys(types).forEach(function (k) {\n  if (k !== 'default') Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () {\n      return types[k];\n    }\n  });\n});\nObject.defineProperty(exports, 'FrameLoop', {\n  enumerable: true,\n  get: function () {\n    return shared.FrameLoop;\n  }\n});\nObject.defineProperty(exports, 'Globals', {\n  enumerable: true,\n  get: function () {\n    return shared.Globals;\n  }\n});\nObject.defineProperty(exports, 'createInterpolator', {\n  enumerable: true,\n  get: function () {\n    return shared.createInterpolator;\n  }\n});\nexports.BailSignal = BailSignal;\nexports.Controller = Controller;\nexports.FrameValue = FrameValue;\nexports.Interpolation = Interpolation;\nexports.Spring = Spring;\nexports.SpringContext = SpringContext;\nexports.SpringHandle = SpringHandle;\nexports.SpringValue = SpringValue;\nexports.Trail = Trail;\nexports.Transition = Transition;\nexports.config = config;\nexports.inferTo = inferTo;\nexports.interpolate = interpolate;\nexports.to = to;\nexports.update = update;\nexports.useChain = useChain;\nexports.useSpring = useSpring;\nexports.useSprings = useSprings;\nexports.useTrail = useTrail;\nexports.useTransition = useTransition;\n//# sourceMappingURL=index.cjs.js.map\n"]},"metadata":{},"sourceType":"script"}